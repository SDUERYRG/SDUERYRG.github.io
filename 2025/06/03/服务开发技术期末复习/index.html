

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="yrg">
  <meta name="keywords" content="">
  
    <meta name="description" content="服务开发技术期末复习第一章 服务计算：Web新时代的计算什么是服务 在一个应用软件内部的一种方法、过程、或通讯。这些“服务”或“方法”是旨在满足某些业务需求的应用程序的操作。所谓服务，是区别于系统的，一个或者一组相对较小且独立的功能单元，是用户可以感知最小功能集  Web Service 指那些自我包含的、自我描述的、模块化的，用于供Web网络上其他软件程序使用或访问的应用程序  API（Appl">
<meta property="og:type" content="article">
<meta property="og:title" content="服务开发技术期末复习">
<meta property="og:url" content="https://sdueryrg.github.io/2025/06/03/%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="yrg的博客">
<meta property="og:description" content="服务开发技术期末复习第一章 服务计算：Web新时代的计算什么是服务 在一个应用软件内部的一种方法、过程、或通讯。这些“服务”或“方法”是旨在满足某些业务需求的应用程序的操作。所谓服务，是区别于系统的，一个或者一组相对较小且独立的功能单元，是用户可以感知最小功能集  Web Service 指那些自我包含的、自我描述的、模块化的，用于供Web网络上其他软件程序使用或访问的应用程序  API（Appl">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sdueryrg.github.io/2025/06/03/%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/HATEOAS%E4%BE%8B%E5%AD%90.png">
<meta property="og:image" content="https://sdueryrg.github.io/2025/06/03/%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E8%85%BE%E8%AE%AF%E5%9C%B0%E5%9B%BE.png">
<meta property="og:image" content="https://sdueryrg.github.io/2025/06/03/%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E5%92%96%E5%95%A1%E5%BA%97%E6%A1%88%E4%BE%8B%E6%84%8F%E4%B9%89.png">
<meta property="og:image" content="https://sdueryrg.github.io/2025/06/03/%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E6%97%A0%E7%8A%B6%E6%80%81%E6%80%A7.png">
<meta property="article:published_time" content="2025-06-03T14:52:31.000Z">
<meta property="article:modified_time" content="2025-06-13T07:38:53.510Z">
<meta property="article:author" content="yrg">
<meta property="article:tag" content="服务开发技术">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://sdueryrg.github.io/2025/06/03/%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/HATEOAS%E4%BE%8B%E5%AD%90.png">
  
  
  
  <title>服务开发技术期末复习 - yrg的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"sdueryrg.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>姚仁广的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="服务开发技术期末复习"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-06-03 22:52" pubdate>
          2025年6月3日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          96 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">服务开发技术期末复习</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="服务开发技术期末复习"><a href="#服务开发技术期末复习" class="headerlink" title="服务开发技术期末复习"></a>服务开发技术期末复习</h1><h2 id="第一章-服务计算：Web新时代的计算"><a href="#第一章-服务计算：Web新时代的计算" class="headerlink" title="第一章 服务计算：Web新时代的计算"></a>第一章 服务计算：Web新时代的计算</h2><h3 id="什么是服务"><a href="#什么是服务" class="headerlink" title="什么是服务"></a>什么是服务</h3><ul>
<li>在一个应用软件内部的一种方法、过程、或通讯。这些“服务”或“方法”是旨在满足某些业务需求的应用程序的操作。所谓服务，是区别于系统的，一个或者一组相对较小且独立的功能单元，是用户可以感知最小功能集</li>
</ul>
<h3 id="Web-Service"><a href="#Web-Service" class="headerlink" title="Web Service"></a>Web Service</h3><ul>
<li>指那些自我包含的、自我描述的、模块化的，用于供Web网络上其他软件程序使用或访问的应用程序</li>
</ul>
<h3 id="API（Application-Programming-Interface）"><a href="#API（Application-Programming-Interface）" class="headerlink" title="API（Application Programming Interface）"></a>API（Application Programming Interface）</h3><ul>
<li>提供对应用程序或数据库中的服务功能和数据进行编程访问的接口，可以用作开发与人类、其他应用程序或智能设备进行交互的基础</li>
</ul>
<h3 id="微服务（Microservice）"><a href="#微服务（Microservice）" class="headerlink" title="微服务（Microservice）"></a>微服务（Microservice）</h3><ul>
<li>微服务架构是一种架构概念，旨在通过将功能分解到各个离散的服务中，以实现对解决方案的解耦。</li>
<li>微服务架构主要作用：<ul>
<li>将功能分解到离散的各个服务当中，从而降低系统的耦合性，并可以提供更加灵活的服务支持</li>
</ul>
</li>
<li>微服务架构的关键在于强调“微服务”可以在自己的程序中运行，每个微服务完全自治，可以独立进化任意修改与重构；如果其中任何一个服务需要增加某种功能，只需要在特定的某种服务中增加所需功能，而不影响架构整体</li>
</ul>
<h2 id="第二章-Web服务技术方案：从RPC到REST"><a href="#第二章-Web服务技术方案：从RPC到REST" class="headerlink" title="第二章 Web服务技术方案：从RPC到REST"></a>第二章 Web服务技术方案：从RPC到REST</h2><h3 id="Web的技术架构包括了四个基石"><a href="#Web的技术架构包括了四个基石" class="headerlink" title="Web的技术架构包括了四个基石"></a>Web的技术架构包括了四个基石</h3><ul>
<li>URI：地址</li>
<li>HTTP：传输</li>
<li>HyperText：表达（除了HTML外，也可以是带有超链接的XML或JSON）</li>
<li>MIME：扩展<ul>
<li>本意为多目的Internet邮件扩展，最初目的是为了在发送电子邮件时附加多媒体数据，让邮件客户程序能根据其类型进行处理。</li>
<li>当它被HTTP协议支持之后，它的意义就更为显著了。它使得HTTP传输的不再是仅有普通的文本，而变得丰富多彩起来</li>
</ul>
</li>
</ul>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><ul>
<li>URL全称为“统一资源定位符（Uniform Resource Locator）”，是URI的一种表现形式</li>
<li>除了标识性之外，它还具有定位的功能，用于描述Web资源所在的位置</li>
<li>URL还指明了获取资源所采用的协议，一个完整的URL包含协议名称、主机名称（IP地址或者域名）、端口号、路径和查询字符串5个部分。</li>
<li>比如对于“<a target="_blank" rel="noopener" href="http://www.artech.com:8080/images/photo.png?size=small%E2%80%9D%E8%BF%99%E6%A0%B7%E4%B8%80%E4%B8%AAURL%EF%BC%8C%E4%B8%8A%E8%BF%B0%E7%9A%845%E4%B8%AA%E9%83%A8%E5%88%86%E5%88%86%E5%88%AB%E6%98%AF%E2%80%9Chttp%E2%80%9D%E3%80%81%E2%80%9Cwww.artech.com%E2%80%9D%E3%80%81%E2%80%9C8080%E2%80%9D%E3%80%81%E2%80%9C/images/photo.png%E2%80%9D%E5%92%8C%E2%80%9C?size=small%E2%80%9D%E3%80%82">http://www.artech.com:8080/images/photo.png?size=small”这样一个URL，上述的5个部分分别是“http”、“www.artech.com”、“8080”、“/images/photo.png”和“?size=small”。</a></li>
<li>URI：Web资源应该有一个唯一的标识。采用Uniform Resource Identifier （URI ）来标识Web资源已经成为了一种共识</li>
</ul>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ul>
<li>HTTP采用简单的请求&#x2F;响应模式的消息交换来实现针对某个Web资源的某种操作</li>
<li>HTTP动词<ul>
<li>POST：向服务器提交信息，一般用于创建资源（增）</li>
<li>GET：获取服务器端的信息，一般用于浏览资源（查）</li>
<li>PUT：用于修改服务器端资源（改）</li>
<li>DELETE：用于删除资源（删）</li>
</ul>
</li>
</ul>
<h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><ul>
<li>起始行<ul>
<li>请求报文利用起始行表示采用的HTTP方法、请求URI和采用的HTTP版本，而响应报文的起始行在承载着HTTP版本和响应状态码等信息。</li>
</ul>
</li>
<li>报头集合<ul>
<li>HTTP报文的起始行后面可以包含零个或者多个报头字段。每个报头字段表现为一个键&#x2F;值对，键和值分别表示报头字段名称和报头字段的值，两者通过冒号（“：”）进行分割。HTTP报文采用一个空行作为报头集合结束的标志</li>
</ul>
</li>
<li>主体内容<ul>
<li>代表报头集合结束标志的空行之后就是HTTP报文的主体部分。客户端提交给服务器的数据一般置于请求报头的主体，而响应报头的主体也承载着服务器返回给客户端的数据</li>
</ul>
</li>
</ul>
<h3 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h3><ul>
<li>Representational State Transfer (REST，中文：表述性状态转移)</li>
<li>REST视角下，互联网就是一个巨大的状态机；REST风格的应用则是从一个状态迁移到下一个状态的状态转移过程</li>
</ul>
<h3 id="三种主流的Web服务实现方案"><a href="#三种主流的Web服务实现方案" class="headerlink" title="三种主流的Web服务实现方案"></a>三种主流的Web服务实现方案</h3><h4 id="远程过程调用-remote-procedure-call，RPC-的分布式计算协议"><a href="#远程过程调用-remote-procedure-call，RPC-的分布式计算协议" class="headerlink" title="远程过程调用(remote procedure call，RPC)的分布式计算协议"></a>远程过程调用(remote procedure call，RPC)的分布式计算协议</h4><ul>
<li>通过XML将调用函数封装，并使用HTTP协议作为传送机制</li>
<li>发出请求的用户端一般都是需要向远端系统要求呼叫的软件</li>
<li>XML-RPC通过向装置了这个调用协议的服务器发出HTTP请求</li>
<li>在新的功能不断被引入下，这个标准慢慢演变成为SOAP协议</li>
</ul>
<h4 id="简单对象访问协议Simple-Object-Access-Protocol-SOAP"><a href="#简单对象访问协议Simple-Object-Access-Protocol-SOAP" class="headerlink" title="简单对象访问协议Simple Object Access Protocol,SOAP"></a>简单对象访问协议Simple Object Access Protocol,SOAP</h4><ul>
<li>SOAP是一种通讯规范，采用标准化的、可分析的结构来传递的消息，消息具有标准的格式，并包含一些通讯双方自定义的语义</li>
<li>比如一个查询房价数据的消息参数中标明这是一个针对某房源价格的查询消息，服务器端将返回一个XML 格式的信息，其中包含了查询结果（价格，位置，特点，或者其他信息）</li>
</ul>
<h4 id="表述性状态转移（Representational-State-Transfer）"><a href="#表述性状态转移（Representational-State-Transfer）" class="headerlink" title="表述性状态转移（Representational State Transfer）"></a>表述性状态转移（Representational State Transfer）</h4><ul>
<li>REST从资源的角度来观察整个网络，分布在各处的资源由URI确定，而客户端的应用通过HTTP操作来获取资源的表征</li>
<li>互联网上的各种资源就好比数据库中的记录，对于资源的操作最后总是能抽象成为查增改删这四种基本操作；在定义了资源定位的规则后，对资源的操作就可以通过标准HTTP 方法GET、PUT、POST、DELETE实现</li>
<li>REST模式的Web 服务将所有Web 系统的服务抽象为资源，并使用标准的HTTP 方法(GET&#x2F;PUT&#x2F;POST&#x2F;DELETE)操作</li>
</ul>
<h3 id="RESTful服务的优势"><a href="#RESTful服务的优势" class="headerlink" title="RESTful服务的优势"></a>RESTful服务的优势</h3><ul>
<li><p>使用统一的接口操作资源</p>
<ul>
<li>由于REST是面向资源的，所以一个Web API旨在实现针对单一资源的操作，针对资源的基本操作唯CRUD而已，故可以为Web API定义标准接口成可能。</li>
<li>所谓的标准接口就是针对不同资源的Web API定义一致性的操作来操作它们</li>
</ul>
</li>
<li><p>RESTful Web服务接口更易于使用</p>
<ul>
<li>RESTful Web服务使用标准的HTTP 方法(GET&#x2F;PUT&#x2F;POST&#x2F;DELETE) 来抽象所有Web 系统的服务能力，而不同的是，SOAP 应用都通过定义自己个性化的接口方法来抽象Web 服务。</li>
<li>标准化的HTTP 操作方法，结合其他的标准化技术，如URI，HTML，XML 等，将会极大提高系统与系统之间整合的互操作能力。更加贴近Web本身的工作方式，也更加自然。</li>
</ul>
</li>
<li><p>无状态性</p>
<ul>
<li>所谓“无状态性”，就是对于分布式的应用任意给定的两个服务请求不依赖彼此，处理一次请求所需的全部信息，要么都包含在这个请求里，要么可以从外部获取到（如数据库），服务端本身不存储任何信息。</li>
<li>HTTP 协议从本质上说是一种无状态的协议，客户端发出的HTTP 请求之间可以相互隔离，不存在相互的状态依赖</li>
<li>基于HTTP 的RESTful服务请求，继承了其“无状态”特性，可以以非常自然的方式来实现无状态服务请求处理逻辑。</li>
</ul>
</li>
<li><p>安全操作与幂指相等特性</p>
<ul>
<li>HTTP 的GET、HEAD 请求本质上应该是安全的调用</li>
<li>即：GET、HEAD 调用不会有任何的副作用，不会造成服务器端状态的改变。</li>
<li>对于服务器来说，客户端对某一URI 做n 次的GET、HAED 调用，其状态与没有做调用是一样的，不会发生任何的改变。</li>
<li>HTTP 的PUT、DELETE 调用，具有幂指相等特性,或称为幂等性(idempotent)</li>
<li>客户端对某一个URI指代的资源执行1次或者多次的PUT、DELETE操作，其效果与执行一次的调用操作是一样的</li>
</ul>
</li>
<li><p>RESTful Web 服务更容易实现缓存</p>
<ul>
<li>当客户端第一次发送HTTP GET 请求给服务器并获得内容后，该内容可以被缓存服务器(Cache Server) 缓存。当下一次客户端请求同样的资源时，缓存可以直接给出响应，而不需要再通过请求远程的服务器获得</li>
</ul>
</li>
</ul>
<h3 id="ROA的协议"><a href="#ROA的协议" class="headerlink" title="ROA的协议"></a>ROA的协议</h3><h4 id="简单对象访问协议（SOAP）"><a href="#简单对象访问协议（SOAP）" class="headerlink" title="简单对象访问协议（SOAP）"></a>简单对象访问协议（SOAP）</h4><ul>
<li>提供了一个标准的封装结构，用来在各种不同的互联网协议（如SMTP、HTTP和FTP）上传输XML文档。通过使用这样的标准消息格式，异构的中间件系统可以实现互操作</li>
</ul>
<h4 id="Web服务描述语言（WSDL）"><a href="#Web服务描述语言（WSDL）" class="headerlink" title="Web服务描述语言（WSDL）"></a>Web服务描述语言（WSDL）</h4><ul>
<li>描述了接口，即Web服务支持的一系列标准格式的操作。它标准化了操作的输入和输出参数的表示以及服务的协议绑定，消息在线传输的方式。使用WSDL，不同的客户端可以自动理解如何与Web服务交互</li>
</ul>
<h4 id="通用描述、发现和集成"><a href="#通用描述、发现和集成" class="headerlink" title="通用描述、发现和集成"></a>通用描述、发现和集成</h4><ul>
<li>提供了一种通过搜索名称、标识符、类别或Web服务实现的规范来广告和发现Web服务的全局注册表</li>
</ul>
<h4 id="REST-1"><a href="#REST-1" class="headerlink" title="REST"></a>REST</h4><h2 id="第三章-资源和表述"><a href="#第三章-资源和表述" class="headerlink" title="第三章 资源和表述"></a>第三章 资源和表述</h2><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><ul>
<li>任何寄宿于Web可供操作的“事物”均可视为资源，就其本质而言，任何足够重要并被引用的事物都可以是资源。</li>
</ul>
<h3 id="资源的表征"><a href="#资源的表征" class="headerlink" title="资源的表征"></a>资源的表征</h3><ul>
<li>资源可以具有多种表现形式，这种资源的呈现形式，称作资源的表征</li>
</ul>
<h3 id="资源需要有唯一的标识符"><a href="#资源需要有唯一的标识符" class="headerlink" title="资源需要有唯一的标识符"></a>资源需要有唯一的标识符</h3><ul>
<li>资源请求者和资源拥有者只有在对事物的命名上达成一致以后才能针对这个事物实现相互通信。</li>
<li>因此，每个资源必须拥有自己的唯一标识，互联网中使用URI 来唯一标记一个资源，包含了URL和URN</li>
<li>URL（Uniform Resource Location）：统一资源定位符，侧重于 “定位” 二字。</li>
<li>URN（Uniform Resource Name）：统一资源名称，侧重于 “命名”二字。</li>
</ul>
<h3 id="为什么要对资源表述"><a href="#为什么要对资源表述" class="headerlink" title="为什么要对资源表述"></a>为什么要对资源表述</h3><ul>
<li>从资源请求者的角度看，它并不关心资源是什么，因为它从来看不到资源，它看到的永远只是资源的URL和表述（Representation）。</li>
<li>客户端应用与服务端的交互，是通过资源的表述来间接完成的，这体现了一些非常好的设计原则：松耦合与前后端分离</li>
<li>通过资源的表述来间接完成交互，实际上就是隔离了客户端与服务端、前端与后端，使得请求服务的一方的操作不会直接影响到服务提供者，而服务提供者也可以安全地分享自己的资源</li>
</ul>
<h3 id="超文本（HyperText）"><a href="#超文本（HyperText）" class="headerlink" title="超文本（HyperText）"></a>超文本（HyperText）</h3><ul>
<li>是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本，其中的文字包含有可以链接到其他文档的地址，以实现从当前阅读位置直接切换到超文本链接所指向的文本继续访问。</li>
</ul>
<h3 id="超媒体（HyperMedia）"><a href="#超媒体（HyperMedia）" class="headerlink" title="超媒体（HyperMedia）"></a>超媒体（HyperMedia）</h3><ul>
<li>是超级媒体的缩写。超媒体是一种采用非线性网状结构对块状多媒体信息（包括文本、图像、视频等）进行组织和管理的技术。</li>
<li>超媒体在本质上和超文本是一样的，只不过超文本技术在诞生的初期管理的对象是纯文本，所以叫做超文本。</li>
</ul>
<h3 id="超媒体策略："><a href="#超媒体策略：" class="headerlink" title="超媒体策略："></a>超媒体策略：</h3><ul>
<li>超媒体可以帮助服务器实现与客户端的对话：服务器在发给客户端的文本中附加超链接，以告知客户端如何进一步向服务器发起请求。</li>
<li>服务提供者可以在发给客户端的文本中附加广告信息的超链接，引导用户新的消费行为。</li>
<li>可以用超媒体写一个服务器提供的功能菜单，客户端可以从中自由选择，目前大多数应用都是这样做的</li>
</ul>
<h3 id="HATEOAS"><a href="#HATEOAS" class="headerlink" title="HATEOAS"></a>HATEOAS</h3><ul>
<li>超文本作为应用程序状态的引擎（Hypertext as the Engine of Application State，HATEOAS）是Rest的一项重要原则<br><img src="/2025/06/03/%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/HATEOAS%E4%BE%8B%E5%AD%90.png" srcset="/img/loading.gif" lazyload alt="HATEOAS例子"></li>
</ul>
<h3 id="HTTP协议语义"><a href="#HTTP协议语义" class="headerlink" title="HTTP协议语义"></a>HTTP协议语义</h3><ul>
<li>尽管任何事物都可以成为一个资源，但是客户端并不能随心所欲地对资源进行任意的操作。所能进行的操作是有规定的。在一个RESTful系统里，客户端和服务器端只能通过相互发送遵循预定义协议的消息来进行交互</li>
<li>在web API的世界里，这个协议就是HTTP。API客户端可以通过发送一些不同类型的HTTP消息与API进行交互</li>
<li>向一个“博客日志”发送的GET请求和向一个“股票代码”发送的GET请求是类似的。这两个请求拥有相同的协议语义，但是却有完全不同的应用语义（application semantic）</li>
<li>无法仅仅通过使用HTTP来满足这样的语义要求，因为HTTP协议并没有定义任何应用语义。但是应用语义必须和HTTP的协议语义保持一致。</li>
</ul>
<h3 id="GET方法"><a href="#GET方法" class="headerlink" title="GET方法"></a>GET方法</h3><ul>
<li>GET是被定义为安全的HTTP方法。它仅仅是对信息的一次请求。向服务资源发送一条GET请求对资源的影响应该和没有发送GET请求一样——也就是，没有任何影响。</li>
<li>GET请求中最常见的响应码是200 (OK)。此外像300 (Moved  Permanently)这样的重定向码也比较常见。</li>
</ul>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><ul>
<li>DELETE很明显不是一个安全的方法。发送一个DELETE请求的效果不同于未发送DELETE请求。但是DELETE方法有另外一个很有用的属性：它是幂等的(idempotent)</li>
<li>一旦你删除了一个资源，这个资源就消失了。资源状态也就永久性地改变了。你可以再次发送一条DELETE请求，这时，你可能会收到一个404错误，但是资源状态和你第一发的送发ELETE请求之后的状态是一致的。资源还是不存在的。这就是幂等性。发送两次请求对资源状态的影响和发送一次请求的影响是一样的</li>
<li>如果一个DELETE请求发送成功了，收到的状态码可能是204（No Content，也就是，“删除成功，我没有其他关于这个资源的信息描述了），也可能是200 （OK，也就是“删除成功，这里是关于它的一条消息”）或者202 (Accepted，也就是“我稍后将删除这个资源”)</li>
<li>幂等性：<ul>
<li>幂等是一个很有用的特性，因为互联网不是一个可靠的网络。</li>
<li>假设你发送了一个DELETE请求，然后你的连接超时了。由于你并没有收到响应信息，所以你无法知道前面的DELETE请求是否顺利完成。你只要再次发送一条DELETE请求并不断重试直到收到响应信息就可以了。</li>
<li>执行两次DELETE请求并不比只执行一次造成更多的影响。</li>
<li>HTTP DELETE方法就相当于用零乘以一个资源。</li>
<li>乘以1是一个安全的运算，HTTP GET也是一个安全的方法。你可以将一个数值不停地乘以1，数值不会产生任何变化。每个安全的运算都是幂等的。</li>
</ul>
</li>
</ul>
<h3 id="POST：POST-to-Append"><a href="#POST：POST-to-Append" class="headerlink" title="POST：POST-to-Append"></a>POST：POST-to-Append</h3><ul>
<li>向某个资源发送一条POST请求用以在该资源的下一级中创送一个新的资源。</li>
<li>当客户端发送一个POST-to-append请求的时候，它会在请求的实体消息体中添加所希望创建的资源的表述信息并发送给服务器</li>
<li>常见的响应码：<ul>
<li>201（Created）它用于告知客户端一个新的资源已经创建成功。</li>
<li>202（Accepted）这表示服务器打算按照提供的表述信息来创建一个资源，但是现在还没有真正创建完成</li>
</ul>
</li>
<li>既不安全也不幂等</li>
</ul>
<h3 id="POST：Overloaded-POST"><a href="#POST：Overloaded-POST" class="headerlink" title="POST：Overloaded POST"></a>POST：Overloaded POST</h3><ul>
<li>大部分浏览器只支持GET&#x2F;POST方法，这使得我们无法完美的实现REST。对于这样的情况，大致有两种解决方法：<ul>
<li>一种是在表单里加入一个_method之类名字的隐藏字段，用于表示真正的方法</li>
<li>另一种是使用X-HTTP-METHOD-OVERRIDE头信息来重载POST</li>
</ul>
</li>
<li>POST不仅仅被用于创建新的资源。在我们用浏览器上网的时候，HTTP POST也被用于传输任何形式的变化。<ul>
<li>它将PUT、DELETE、PATCH、LINK和UNLINK所有的方法混合成一个方法</li>
</ul>
</li>
<li>将POST这种“任意而为(whatever)”用法称为重载的(overloaded) POST</li>
<li>因为一个重载的POST请求没有协议语义，你只能在应用语义的层面上来理解它</li>
<li>不安全也不幂等（在事实上可能安全，在HTTP上是不安全的）</li>
</ul>
<h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><ul>
<li>PUT请求是用于修改资源状态的请求。客户端一般会通过GET请求获取表述，然后对其进行修改，最后再将修改后的资源表述作为PUT请求的负载数据(payload)发送回去。</li>
<li>返回200（OK）或204（No Content）</li>
<li>幂等，如果你发送10次同样的PUT请求，请求的结果和你只发1次请求的结果是一样的</li>
<li>如果客户端知道新资源的URL的话，它同样能够使用PUT来新建一个资源。</li>
<li>即便我们用PUT来创建一个新的资源，PUT也还是一个幂等的操作。</li>
<li>如果我发送5次PUT请求，这并不会相应生成5条具有同样内容的微博（而5次POST请求会生成5条相同的微博）</li>
</ul>
<h3 id="PUT-VS-POST"><a href="#PUT-VS-POST" class="headerlink" title="PUT VS POST"></a>PUT VS POST</h3><ul>
<li>区别在于POST是作用在一个集合资源之上的（&#x2F;articles），而PUT操作是作用在一个具体资源之上的（&#x2F;articles&#x2F;123）</li>
<li>如果URL可以在客户端确定，那么就使用PUT</li>
<li>如果是在服务端确定，那么就使用POST</li>
<li>比如说很多资源使用数据库自增主键作为标识信息而创建的资源的标识信息到底是什么只能由服务端提供，这个时候就必须使用POST</li>
</ul>
<h3 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h3><ul>
<li>表述的信息量可能非常大。“修改表述，然后通过PUT方法提交”是一个简单的规则</li>
<li>但是如果你只是想修改资源状态中的很小的一部分，这就可能造成极大的浪费。</li>
<li>此外，PUT规则还可能导致与其他修改同样文档的用户发生意外的修改冲突。</li>
<li>如果你可以仅仅向服务器发送你想要修改的那一部分数据文档，那PATCH方法就提供了这样的功能来允许你这么做</li>
<li>和将完整的表述信息通过PUT方法发送出去不同，你可以建立一个特别的“diff‘’表述，并将它作为PATCH请求的负载数据发送给服务器</li>
<li>不安全也不保证幂等</li>
<li>一个PATCH 请求有可能结果是等幂的，这种情况下，如果你不小心对同一个文档应用了两次patch，你可能会在第二次收到一个错误信息。但这并没有定义在相关标准中。</li>
</ul>
<h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><ul>
<li>和GET一样安全，可理解为轻量版GET</li>
<li>服务器和GET一样处理HEAD，但不返回消息体，只需发送状态码和报头</li>
<li>（待定）HEAD代替GET不会节约时间，因为服务器还是需要生成所有HTTP报头，但能节省带宽</li>
</ul>
<h3 id="OPTION"><a href="#OPTION" class="headerlink" title="OPTION"></a>OPTION</h3><ul>
<li>一个OPTIONS请求的返回结果包含一个HTTP Allow报头，这个报头展示了这个资源所支持的所有的HTTP方法。</li>
</ul>
<h3 id="响应码"><a href="#响应码" class="headerlink" title="响应码"></a>响应码</h3><h4 id="1xx相关信息（不常用）"><a href="#1xx相关信息（不常用）" class="headerlink" title="1xx相关信息（不常用）"></a>1xx相关信息（不常用）</h4><table>
<thead>
<tr>
<th>状态码</th>
<th>内容</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>Continue</td>
<td>继续。客户端应继续其请求</td>
</tr>
<tr>
<td>101</td>
<td>Switching Protocols</td>
<td>切换协议。服务器根据客户端的请求切换协议。智能切换到更高的协议，例如，切换到HTTP的新版本协议</td>
</tr>
</tbody></table>
<h4 id="2xx操作成功"><a href="#2xx操作成功" class="headerlink" title="2xx操作成功"></a>2xx操作成功</h4><table>
<thead>
<tr>
<th>状态码</th>
<th>内容</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK</td>
<td>请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>已创建。成功请求并创建新的资源</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td>已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td>203</td>
<td>Non-Authoritative Information</td>
<td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td>205</td>
<td>Reset Content</td>
<td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td>206</td>
<td>Partial Content</td>
<td>部分内容。服务器成功处理了部分GET请求</td>
</tr>
</tbody></table>
<h4 id="3xx重定向（不常用）"><a href="#3xx重定向（不常用）" class="headerlink" title="3xx重定向（不常用）"></a>3xx重定向（不常用）</h4><table>
<thead>
<tr>
<th>状态码</th>
<th>内容</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>300</td>
<td>Multiple Choices</td>
<td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently</td>
<td>永久移动。请求的资源已被永久的移动到新的URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td>查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy</td>
<td>使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td>306</td>
<td>Unused</td>
<td>已经废弃的HTTP状态码</td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect</td>
<td>临时重定向。与302类似。使用GET请求重定向</td>
</tr>
</tbody></table>
<h4 id="4xx客户端错误"><a href="#4xx客户端错误" class="headerlink" title="4xx客户端错误"></a>4xx客户端错误</h4><table>
<thead>
<tr>
<th>状态码</th>
<th>内容</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>400</td>
<td>Bad Request</td>
<td>客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>请求要求用户的身份认证</td>
</tr>
<tr>
<td>402</td>
<td>Payment Required</td>
<td>保留，将来使用</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置“您所请求的资源无法找到”的个性页面</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed</td>
<td>客户端请求中的方法被禁止</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable</td>
<td>服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td>407</td>
<td>Proxy Authentication Required</td>
<td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td>408</td>
<td>Request Time-out</td>
<td>服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td>409</td>
<td>Conflict</td>
<td>服务器完成客户端的PUT请求时可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td>410</td>
<td>Gone</td>
<td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td>411</td>
<td>Length Required</td>
<td>服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td>412</td>
<td>Precondition Failed</td>
<td>客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td>413</td>
<td>Request Entity Too Large</td>
<td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td>414</td>
<td>Request-URI Too Large</td>
<td>请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td>415</td>
<td>Unsupported Media Type</td>
<td>服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td>416</td>
<td>Requested range not satisfiable</td>
<td>客户端请求的范围无效</td>
</tr>
<tr>
<td>417</td>
<td>Expectation Failed</td>
<td>服务器无法满足Expect的请求头信息</td>
</tr>
</tbody></table>
<h4 id="5xx服务器错误"><a href="#5xx服务器错误" class="headerlink" title="5xx服务器错误"></a>5xx服务器错误</h4><table>
<thead>
<tr>
<th>状态码</th>
<th>内容</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented</td>
<td>服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td>充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td>由于超载或系统维护，服务器暂时无法处理客户端的请求。延时长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Time-out</td>
<td>充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version not supported</td>
<td>服务器不支持请求的HTTP协议版本，无法完成处理</td>
</tr>
</tbody></table>
<h2 id="第五章-领域驱动的服务设计"><a href="#第五章-领域驱动的服务设计" class="headerlink" title="第五章 领域驱动的服务设计"></a>第五章 领域驱动的服务设计</h2><h3 id="领域建模产出物"><a href="#领域建模产出物" class="headerlink" title="领域建模产出物"></a>领域建模产出物</h3><ul>
<li>领域模型：包含领域对象、属性、关系、行为、边界范围等各个方面，用于描述业务的本质</li>
<li>用例图：用于明确系统的功能</li>
<li>数据模型：描述系统的数据结构和关系，包括实体关系模型、关系数据库模型等</li>
<li>状态图：用于描述系统各个状态及其转移条件</li>
<li>活动图：用于描述系统流程中的各个活动及其关系</li>
<li>序列图：描述系统中各个对象之间的交互过程和消息传递序列</li>
<li>架构模型：包含系统的物理和逻辑结构，包括组件、模块、接口等</li>
</ul>
<h3 id="领域驱动设计（DDD）"><a href="#领域驱动设计（DDD）" class="headerlink" title="领域驱动设计（DDD）"></a>领域驱动设计（DDD）</h3><ul>
<li>针对一个领域内各个业务需求进行建模，同时提供了战略和战术上的建模方法和工具。</li>
<li>模型驱动的思想：通过建立领域模型来描述领域中的核心问题</li>
</ul>
<h3 id="DDD主要任务"><a href="#DDD主要任务" class="headerlink" title="DDD主要任务"></a>DDD主要任务</h3><ul>
<li>一是如何发现系统中的聚合(Aggregate)<ul>
<li>所谓聚合是一组相关的领域对象（或者称为实体），是由业务和逻辑紧密关联的实体和值对象组合而成的，值对象可以理解为实际的Entity对象的一个属性的结合，附属在一个实际的实体对象上面</li>
</ul>
</li>
<li>二是如何划分限界上下文(Bounded Context)<ul>
<li>系统的上下文（context）指的是目标系统、与之交互的用户和外部系统</li>
</ul>
</li>
</ul>
<h2 id="第六章-设计只读的资源服务"><a href="#第六章-设计只读的资源服务" class="headerlink" title="第六章 设计只读的资源服务"></a>第六章 设计只读的资源服务</h2><h3 id="ROA-vs-RPC"><a href="#ROA-vs-RPC" class="headerlink" title="ROA vs RPC"></a>ROA vs RPC</h3><ul>
<li>面向对象程序的标准设计方法是把系统分解为一个个功能部件——即其中的名词(nouns)。<ul>
<li>一个对象(object)是(is)某个事物（如“读者”、“栏目”、“报道”、“评论”等）。</li>
<li>每个名词都有自己的类和自己的方法（用以与其他名词交互）</li>
</ul>
</li>
<li>与此形成对比的是，RPC式架构的设计方法是把系统分解为一个个动作，即其中的动词(verbs)。<ul>
<li>一个过程(procedure)做(does)某些操作（比如“订阅”、“阅读”、“作评论”等），在面向RPC的分析中，它会被视为将被客户端调用的动作(action)</li>
</ul>
</li>
</ul>
<h3 id="ROA"><a href="#ROA" class="headerlink" title="ROA"></a>ROA</h3><ul>
<li>一个资源(resource)是(is)某个事物，所以适合用面向对象的方法来设计资源</li>
<li>编程语言里的一个类(class)可以暴露无数个方法(methods)，并给这些方法取任意名(name)</li>
<li>但是，一个资源只暴露一个统一接口，最多支持六种HTTP方法，这些方法只允许创建(PUT或POST)、修改(PUT)、读取(GET)和删除(DELETE)这些最基本的操作<ul>
<li>如果需要，也可以通过重载(overload) POST来扩展该接口，把一个资源变成一个小型RPC式消息处理器。不过一般不鼓励这样</li>
</ul>
</li>
<li>统一接口(uniform interface)意味着，在面向对象设计里被视为动词(verb)的事物，在面向资源的设计里必须被视为对象(object)</li>
</ul>
<h3 id="资源分析与设计"><a href="#资源分析与设计" class="headerlink" title="资源分析与设计"></a>资源分析与设计</h3><ul>
<li>理解服务功能</li>
<li>梳理所拥有的资源</li>
<li>创建只读资源<ul>
<li>设定资源入口：必须有一个所有可用资源的最上层目录，例如地图网站的首页，需要将这个资源入口的URL公布出去，作为获取其他资源的入口。</li>
<li>根据服务确定需要暴露的资源：一个服务可以暴露很多对象，每一种都有自己的资源集合。比如我们要开发的地图服务如果要提供可视化的地图展现，就需要提供地图图片；如果服务提供地点的精确位置信息，就需要知道地点对应经纬度（这些数据可能存储在关系数据库中）。</li>
<li>作为查询结果的集合资源：地图服务通过资源来最终暴露数据和产生数据的算法，比如地图上的路径规划，实际上是一个有条件约束的最短路径算法，执行以后会得到一个地点序列，构成路径。</li>
</ul>
</li>
<li>给资源命名<ul>
<li>资源命名需要精巧地设计，确保资源命名规则的合理、规范、一致，更重要的是要易于扩展，因为很多情况下（甚至可以说绝大多数情况下），资源名字都是由程序自动生成的。</li>
<li>针对资源特点和设计经验，我们的URI设计基于三条基本原则：<ul>
<li>用路径变量(path variables)来表达层次结构(hierarchy)，如: &#x2F;parent&#x2F;child</li>
<li>在路径变量里用标点符号表达多个信息，如经纬度：&#x2F;24.9195,17.821</li>
<li>用查询变量(query variables)来表达算法的输入，例如：&#x2F;search?q&#x3D;j ellyfish&amp;start&#x3D;20</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="设计资源表述"><a href="#设计资源表述" class="headerlink" title="设计资源表述"></a>设计资源表述</h3><h4 id="传达资源状态的表述"><a href="#传达资源状态的表述" class="headerlink" title="传达资源状态的表述"></a>传达资源状态的表述</h4><ul>
<li>传达资源状态是表述(representation)的主要用途</li>
<li>“资源状态”就是有关资源的任何信息。在我们的服务里，资源状态将回答类似这样的问题：<ul>
<li>某一个地点的地图是什么样的？</li>
<li>某个地点的经纬度是多少？</li>
<li>附近哪里有餐厅，它们都叫什么名称？等等</li>
</ul>
</li>
<li>不同资源的表述传达的是不同的状态</li>
</ul>
<h4 id="推进状态"><a href="#推进状态" class="headerlink" title="推进状态"></a>推进状态</h4><ul>
<li>表述(representation)的另一个用途是推进状态</li>
<li>一个资源的表述应该链接到邻近的资源（这里“邻近”的含义依据上下文而定），比如可能的下个应用状态(application state)。这样做是为了实现连通性(connectedness)——通过跟随链接(following links)从一个资源到另一个资源的能力</li>
<li>网站就是这样工作的：<ul>
<li>你在上网时不是接连输入URls，相反，你先通过输入URI进入网站的主页，然后通过跟随链接来浏览网页。一个网页（该网站的一个“状态”）包含指向其他相关网页（邻近“状态”）的链接</li>
</ul>
</li>
</ul>
<h3 id="表述格式的选择"><a href="#表述格式的选择" class="headerlink" title="表述格式的选择"></a>表述格式的选择</h3><ul>
<li>纯文本： <code>http://maps.example.com/China/Beijing</code></li>
<li>纯文本比较简单，但它需要专用的解析器。一般来说，结构化数据格式要比纯文本好，尤其当表述比较复杂时，可以用结构化的文本格式，它保留了纯文本简单的优点，同时增加了一些结构信息，比如：<code>[&#123;url=&quot;http://maps.example.com/China/Beijing, description=&quot;Beijing，a city of China&quot;&#125;]</code></li>
<li>纯文本和Json的缺点：它们都不是通常所认为的“超媒体”格式，即没法直接在浏览器中解析使用，如图所示腾讯地图返回的Json格式表述在浏览器中的显示结果仍然是文本；而XML格式的文档中虽然有自描述的结构信息，也没有用于展现的格式信息。<br><img src="/2025/06/03/%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E8%85%BE%E8%AE%AF%E5%9C%B0%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="腾讯地图"></li>
<li>折中：XHTML，可扩展超文本标记语言</li>
<li>原因：标准的XHTML文档兼容HTML，保留了浏览器呈现格式所需的标记，所有浏览器都能够正确显示；同时，XHTML又是可扩展的，每个标签都增加了一个class属性，通过使用class属性，可以传递资源的更多信息，比如：<figure class="highlight xhtml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs XHTML"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;Map&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/China&quot;</span>&gt;</span>China<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/France&quot;</span>&gt;</span>France<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> ...<br> <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li>这种为XHTML标签增加语义的方式又称为微格式，微格式是一套建立在现有的、广泛采用的标准之上的、简单而开放的数据格式。</li>
<li>这样引入语义信息对浏览器等所有现存的Web技术冲击最小。</li>
<li>下面的一段文字通过class定义了明确的结构语义，从”adr”、”street-address”、”tel”、”email”等这些属性名字看，这里表达的是一个地址信息，这些内容可以被获得这个表述的程序解析使用。<figure class="highlight xhtml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs XHTML"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;vcard&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fn org&quot;</span>&gt;</span>Wikimedia Foundation Inc.<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;adr&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;street-address&quot;</span>&gt;</span>200 2nd Ave. South #358<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;locality&quot;</span>&gt;</span>St. Petersburg<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>,<br> <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;region&quot;</span>&gt;</span>FL<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;postal-code&quot;</span>&gt;</span>33701-4313<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;country-name&quot;</span>&gt;</span>USA<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li>这段文字嵌入HTML中，在浏览器中，会显示一段有格式的资源信息，可以尝试一下，去掉文字中所有的class字段，显示的内容是一样的</li>
<li>XHTML微格式实际是为现有HTML元素添加元数据和其他属性，通过XML把结构语义嵌入到HTML增强语义，兼顾人机可读性</li>
</ul>
<h3 id="规划服务交互的响应"><a href="#规划服务交互的响应" class="headerlink" title="规划服务交互的响应"></a>规划服务交互的响应</h3><ul>
<li>服务的设计者需要有非常清晰的思路：在设计时想清楚在服务双方的往来交互中会发生哪些典型的事件？</li>
<li>用户向一个URI发出GET请求，服务器返回正确的响应代码（比如200）、一些HTTP报头（HTTP headers）及一个实体主体（表述）</li>
<li>这里最重要的问题是：客户端的请求和服务器的响应里分别应包含哪些HTTP报头，以及，确保服务器能对客户端的请求作出正确的响应</li>
<li>HTTP响应报头包含很多信息<ul>
<li>Content -Type是最重要的HTTP响应报头，它告诉客户端表述的媒体类型(media type of the representation)，对于地图和搜索结果来说，<code>application/xhtml+xml</code>，对于地图图像来说，<code>image/png</code></li>
</ul>
</li>
</ul>
<h4 id="条件HTTP-GET"><a href="#条件HTTP-GET" class="headerlink" title="条件HTTP GET"></a>条件HTTP GET</h4><ul>
<li>有些资源不会变化但会被多次请求，大部分时候，客户端对一个资源的第二次（及以后多次）HTTP请求完全可以重用上一次请求时获得的表述。此时服务器返回一个表述时，服务器应该为Last-Modified报头设置一个时间值，表示数据最后更新的时间。当客户端再次请求时，在If-Modified-Since报头里提供那个最后更新时间</li>
<li>加入资源发生了变化，服务器返回200（OK），并在实体主体里提供最新的表述————与一次正常HTTP请求一样</li>
<li>若数据没有变化，服务器将返回304（Not Modified），并省去实体主体，这样客户端就直到可以重用已缓存的表述了</li>
<li>优点：客户端和服务器双方均节省了时间与带宽</li>
</ul>
<h3 id="只读的面向资源服务的设计过程："><a href="#只读的面向资源服务的设计过程：" class="headerlink" title="只读的面向资源服务的设计过程："></a>只读的面向资源服务的设计过程：</h3><ul>
<li>资源分析与设计</li>
<li>设计资源表述</li>
<li>把资源互相联系起来</li>
<li>规划服务交互的响应</li>
</ul>
<h2 id="第七章-Restful服务的安全性"><a href="#第七章-Restful服务的安全性" class="headerlink" title="第七章 Restful服务的安全性"></a>第七章 Restful服务的安全性</h2><h3 id="如何保证"><a href="#如何保证" class="headerlink" title="如何保证"></a>如何保证</h3><ul>
<li>对客户端做身份认证</li>
<li>对敏感的数据做加密，并且防止篡改<ul>
<li>常见做法：部署SSL(Secure Sockets Layer 安全套接层)基础设施（即HTTPS），敏感数据的传输全部基于SSL；或者仅对部分敏感数据加密，并加入某种随机数作为加密盐，以防数据被篡改</li>
</ul>
</li>
<li>身份认证之后的访问控制<ul>
<li>主要是由应用来控制。通常应该实现某种基于角色+用户组的授权机制，即基于角色的访问控制（Role-Based Access Control，RBAC）</li>
</ul>
</li>
</ul>
<h3 id="身份验证和授权方法"><a href="#身份验证和授权方法" class="headerlink" title="身份验证和授权方法"></a>身份验证和授权方法</h3><h4 id="Basic认证"><a href="#Basic认证" class="headerlink" title="Basic认证"></a>Basic认证</h4><ul>
<li>认证模式：用户名+密码+Base64</li>
<li>每次请求都带着用户名和密码</li>
</ul>
<h4 id="摘要-Digest-认证"><a href="#摘要-Digest-认证" class="headerlink" title="摘要(Digest)认证"></a>摘要(Digest)认证</h4><ul>
<li>认证模式：md5加密&#x3D;摘要</li>
<li>过程：<ul>
<li>服务器产生一个随机数nonce，放在在WWW-Authenticate响应头，与服务器支持的认证算法列表，认证的域realm等一起发送给客户端。</li>
<li>客户端输入用户名和密码，并计算出密码和其他需要加密的数据的摘要，并放在Authorization的请求头中发送给服务器</li>
<li>服务从请求信息中提取出摘要，与自身保存的用户名密码计算所得摘要进行比对</li>
<li>如果验证通过，则返回：200 OK</li>
</ul>
</li>
<li>随机数作用：能够防止完全相同的请求的重放</li>
</ul>
<h4 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h4><ul>
<li>Basic认证和摘要认证都是单次认证，每次用户发起请求都需要重复认证</li>
<li>认证模式：用户名+密码+访问令牌+刷新令牌</li>
<li>核心思想：用户使用用户名和密码登录系统后，客户端（用户访问系统的设备）会收到一对令牌，包括访问权限令牌和刷新令牌。</li>
<li>访问令牌用于访问系统中的所有服务。</li>
<li>到期后，系统使用刷新令牌生成一对新的令牌。</li>
</ul>
<h4 id="Bearer-Token"><a href="#Bearer-Token" class="headerlink" title="Bearer Token"></a>Bearer Token</h4><ul>
<li>Oauth2.0规范的组成部分</li>
</ul>
<h4 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h4><ul>
<li>规定了一种JSON格式的Token实现方式</li>
<li>包含：头、荷载和签名<ul>
<li>头：包含加密算法令牌类型等信息</li>
<li>载荷：包含用户信息签发时间和过期时间等信息</li>
<li>签名：根据头、载荷及密钥加密得到的哈希串，默认使用HS256 （HmacSha1 256）。作用是保证JWT没有被篡改</li>
</ul>
</li>
</ul>
<h3 id="Session-vs-JWT"><a href="#Session-vs-JWT" class="headerlink" title="Session vs JWT"></a>Session vs JWT</h3><h4 id="传统的session认证"><a href="#传统的session认证" class="headerlink" title="传统的session认证"></a>传统的session认证</h4><ul>
<li>http协议本身是一种无状态的协议，为了让应用能识别是哪个用户发出的请求，<strong>只能在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为cookie，以便下次请求时发送给应用</strong>，这样应用就能识别请求来自哪个用户了，这就是传统的基于session认证</li>
</ul>
<h4 id="基于token的鉴权机制"><a href="#基于token的鉴权机制" class="headerlink" title="基于token的鉴权机制"></a>基于token的鉴权机制</h4><ul>
<li>基于token的鉴权机制不需要在服务端去保留用户的认证信息或者会话信息。这就意味着应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利</li>
</ul>
<h2 id="第九章-星巴克案例"><a href="#第九章-星巴克案例" class="headerlink" title="第九章 星巴克案例"></a>第九章 星巴克案例</h2><h3 id="案例的意义"><a href="#案例的意义" class="headerlink" title="案例的意义"></a>案例的意义</h3><p><img src="/2025/06/03/%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E5%92%96%E5%95%A1%E5%BA%97%E6%A1%88%E4%BE%8B%E6%84%8F%E4%B9%89.png" srcset="/img/loading.gif" lazyload alt="咖啡店案例意义"></p>
<h3 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h3><h4 id="通过缓存提升可伸缩性"><a href="#通过缓存提升可伸缩性" class="headerlink" title="通过缓存提升可伸缩性"></a>通过缓存提升可伸缩性</h4><ul>
<li>作为经营者，其实很不喜欢业务波动，不希望给服务增添负担、或者徒然增加业务流量。</li>
<li>为防止服务因过载而崩溃，可以使用一个逆向代理（reverse proxy）来缓存并提供那些频繁访问的资源表述</li>
<li>在架构里增设了Web缓存（逆向代理），再加上有缓存元数据，客户端获取资源时就不会给服务器增添很大负担了</li>
</ul>
<h4 id="无状态性"><a href="#无状态性" class="headerlink" title="无状态性"></a>无状态性</h4><ul>
<li>所谓有状态指的是要求在多个异步操作的序列间维持事务资源的一定状态，但这就阻碍了消息的自由传递，因为消息只能向特定服务器传递，系统无法横向扩展，这也就等于损害了可伸缩性<br><img src="/2025/06/03/%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E6%97%A0%E7%8A%B6%E6%80%81%E6%80%A7.png" srcset="/img/loading.gif" lazyload alt="无状态性"></li>
</ul>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><ul>
<li>重试</li>
<li>补偿：补偿是回退所有已完成的操作，让系统回到一致的状态。例如：退款&#x2F;重新发货</li>
</ul>
<h4 id="善用状态码"><a href="#善用状态码" class="headerlink" title="善用状态码"></a>善用状态码</h4><h2 id="第十章-RESTful服务开发-Jersey"><a href="#第十章-RESTful服务开发-Jersey" class="headerlink" title="第十章 RESTful服务开发(Jersey)"></a>第十章 RESTful服务开发(Jersey)</h2><h3 id="服务设计步骤"><a href="#服务设计步骤" class="headerlink" title="服务设计步骤"></a>服务设计步骤</h3><ul>
<li>资源分析与设计</li>
<li>客户端表述的设计</li>
<li>服务端表述的设计</li>
<li>暴露资源可执行接口</li>
<li>多种资源整合到一起</li>
<li>规划服务交互的响应</li>
</ul>
<h3 id="服务开发步骤"><a href="#服务开发步骤" class="headerlink" title="服务开发步骤"></a>服务开发步骤</h3><ul>
<li>设置开发环境，导入必要的框架</li>
<li>开发环境中创建一个web工程</li>
<li>描述服务接口</li>
<li>实现服务功能</li>
</ul>
<h3 id="Jersey常用注解"><a href="#Jersey常用注解" class="headerlink" title="Jersey常用注解"></a>Jersey常用注解</h3><ul>
<li>@Path，标注资源类或者方法的相对路径；</li>
<li>@GET，@PUT，@POST，@DELETE标注方法是HTTP请求的类型；</li>
<li>@Produces，标注返回的MIME媒体类型；</li>
<li>@Consumes，标注可接受请求的MIME媒体类型；</li>
<li>@PathParam，@QueryParam，@HeaderParam，@CookieParam，@MatrixParam，@FormParam标注方法的参数分别来自于HTTP请求的不同位置。<ul>
<li>例如@PathParam来自于URL的路径，@QueryParam来自于URL的查询参数，</li>
<li>@HeaderParam来自于HTTP请求头信息，@CookieParam来自于HTTP请求的Cookie</li>
</ul>
</li>
</ul>
<h3 id="Path"><a href="#Path" class="headerlink" title="@Path"></a>@Path</h3><ul>
<li>定义资源的访问路径，注解的值是一个相对的URI路径。client通过这个路径访问资源。比如：@Path(“user”)</li>
</ul>
<h3 id="为资源方法指定符-resource-method-designator"><a href="#为资源方法指定符-resource-method-designator" class="headerlink" title="为资源方法指定符(resource method designator)"></a>为资源方法指定符(resource method designator)</h3><ul>
<li>与HTTP规范中定义的方法一致</li>
<li>@GET, @PUT, @POST, @DELETE, @HEAD</li>
</ul>
<h3 id="Produces"><a href="#Produces" class="headerlink" title="@Produces"></a>@Produces</h3><ul>
<li>可以用于注解类或者注解方法，指定返回给客户端的MIME媒体类型，即服务器端产生的响应实体的媒体类型</li>
<li>方法的@Produces注释将会覆盖类的注释。资源按照指定数据格式返回，可以是XML、Json等媒体类型。</li>
<li>可取的值有：<ul>
<li>@Produces(MediaType.TEXT_PLAIN)</li>
<li>@Produces(MediaType.APPLICATION_JSON)</li>
<li>@Produces(MediaType.APPLICATION_XML)</li>
</ul>
</li>
<li>服务端可以指定优先回复某一种类型，如下qs&#x3D;0.9指定XML格式优先级更高。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@GET</span><br><span class="hljs-meta">@Produces(&#123;&quot;application/xml; qs=0.9&quot;, &quot;application/json&quot;&#125;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">doGetAsXmlOrJson</span><span class="hljs-params">()</span> &#123;<br> ...&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="Consumes"><a href="#Consumes" class="headerlink" title="@Consumes"></a>@Consumes</h3><ul>
<li>指定可以接受的客户端请求的MIME媒体类型。只有符合这个参数设置的请求才能访问到这个资源。</li>
<li>例如：@Consumes(“application&#x2F;x-www-form-urlencoded”)接受表单数据；@Consumes(“text&#x2F;plain”)接受纯文本数据</li>
</ul>
<h3 id="参数注解"><a href="#参数注解" class="headerlink" title="参数注解"></a>参数注解</h3><h4 id="PathParam"><a href="#PathParam" class="headerlink" title="@PathParam"></a>@PathParam</h4><ul>
<li>用于提取路径中的参数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GET</span><br><span class="hljs-meta">@Path(&quot;&#123;username&#125; &quot;)</span><br><span class="hljs-meta">@Produces(MediaType.APPLICATION_JSON)</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUser</span><span class="hljs-params">(<span class="hljs-meta">@PathParam(&quot;username&quot;)</span> String userName)</span> &#123;<br> <span class="hljs-comment">//...</span><br> &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="QueryParam"><a href="#QueryParam" class="headerlink" title="@QueryParam"></a>@QueryParam</h4><ul>
<li>用于提取查询参数。获取请求中的查询参数，这些参数在URL中跟在“？”符号后面。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GET</span><br><span class="hljs-meta">@Path(&quot;/user&quot;)</span><br><span class="hljs-meta">@Produces(&quot;text/plain&quot;)</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUser</span><span class="hljs-params">(<span class="hljs-meta">@QueryParam(&quot;name&quot;)</span> String name, <span class="hljs-meta">@QueryParam(&quot;age&quot;)</span> <span class="hljs-type">int</span> age)</span> <br>&#123; ...&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="DefaultValue"><a href="#DefaultValue" class="headerlink" title="@DefaultValue"></a>@DefaultValue</h4><ul>
<li>默认参数值。可指定参数的缺省值:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GET</span><br><span class="hljs-meta">@Path(&quot;/user&quot;)</span><br><span class="hljs-meta">@Produces(&quot;text/plain&quot;)</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUser</span><span class="hljs-params">(<span class="hljs-meta">@QueryParam(&quot;name&quot;)</span> String name, <span class="hljs-meta">@DefaultValue(&quot;26&quot;)</span> <span class="hljs-meta">@QueryParam(&quot;age&quot;)</span> <span class="hljs-type">int</span> age)</span> &#123; ...&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="MatrixParam"><a href="#MatrixParam" class="headerlink" title="@MatrixParam"></a>@MatrixParam</h4><ul>
<li>矩阵参数，提取URL路径中嵌入的任意个数个name 和value的键值对<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Path(&quot;/books&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookService</span> &#123;<br><span class="hljs-meta">@GET</span><br><span class="hljs-meta">@Path(&quot;&#123;author&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Response <span class="hljs-title function_">getBooks</span><span class="hljs-params">(<span class="hljs-meta">@PathParam(&quot;author &quot;)</span> String author,<span class="hljs-meta">@MatrixParam(&quot;bookname&quot;)</span> String bookname,<span class="hljs-meta">@MatrixParam(&quot;publisher&quot;)</span> String publisher)</span> &#123;<br> <span class="hljs-keyword">return</span> Response<br> .status(<span class="hljs-number">200</span>)<br> .entity(<span class="hljs-string">&quot;getBooks is called, author : &quot;</span> + author<br> + <span class="hljs-string">&quot;, bookname : &quot;</span> + bookname + <span class="hljs-string">&quot;, publisher : &quot;</span> + publisher)<br> .build();<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="HeaderParam"><a href="#HeaderParam" class="headerlink" title="@HeaderParam"></a>@HeaderParam</h4><ul>
<li>从请求的头部提取Header</li>
</ul>
<h4 id="CookieParam"><a href="#CookieParam" class="headerlink" title="@CookieParam"></a>@CookieParam</h4><ul>
<li>提取cookie</li>
</ul>
<h4 id="Context"><a href="#Context" class="headerlink" title="@Context"></a>@Context</h4><ul>
<li>标注上下文</li>
<li>大型的服务器中由于参数的多变，参数结构的调整很容易遇到问题，可使用@Context来注解上下文，获取与请求或响应相关的上下文Java类型</li>
<li>注入ResourceInfo、UriInfo、HttpHeaders、ServletConfig、ServletContext、HttpServletRequest、HttpServletResponse、SecurityContext等对象</li>
<li>配合使用HTTP头上下文，可获取header和cookie的所有值：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GET</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-meta">@Context</span> HttpHeaders hh)</span> &#123;<br>    MultivaluedMap&lt;String, String&gt; headerParams = hh.getRequestHeaders();<br>    Map&lt;String, Cookie&gt;cookieParams = hh.getCookies();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="FormParam"><a href="#FormParam" class="headerlink" title="@FormParam"></a>@FormParam</h4><ul>
<li>从POST请求的表单中获取数据；用于提取请求中媒体类型</li>
<li>为”application&#x2F;x-www-form-urlencoded” 的参数，根据相应表单类型提取其中的参数。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@POST</span><br><span class="hljs-meta">@Consumes(&quot;application/x-www-form-urlencoded&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">post</span><span class="hljs-params">(<span class="hljs-meta">@FormParam(&quot;name&quot;)</span> String name)</span> &#123; <br>    <span class="hljs-comment">//</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="BeanParam"><a href="#BeanParam" class="headerlink" title="@BeanParam"></a>@BeanParam</h4><ul>
<li>用于从请求的各部分中提取参数，并注入到对应的Bean中</li>
</ul>
<h2 id="第十二章-OpenAPI规范与设计"><a href="#第十二章-OpenAPI规范与设计" class="headerlink" title="第十二章 OpenAPI规范与设计"></a>第十二章 OpenAPI规范与设计</h2><h3 id="OpenAPI规范的作用"><a href="#OpenAPI规范的作用" class="headerlink" title="OpenAPI规范的作用"></a>OpenAPI规范的作用</h3><ul>
<li>定义了一个标准的、语言无关的RESTful API 接口规范</li>
<li>正确定义规范文档后，开发者就可以使用最少的实现逻辑来理解远程服务并与之交互</li>
<li>此外，借助于文档生成工具，可以使用OpenAPI规范来生成API 文档，代码生成工具可以生成各种编程语言下的服务端和客户端代码，测试代码和其他用例</li>
</ul>
<h2 id="第十三章-微服务架构"><a href="#第十三章-微服务架构" class="headerlink" title="第十三章 微服务架构"></a>第十三章 微服务架构</h2><h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><ul>
<li>微服务是由以单一应用程序构成的小服务，自己拥有自己的进程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用HTTP API通信；</li>
</ul>
<h3 id="微服务-vs-单体系统"><a href="#微服务-vs-单体系统" class="headerlink" title="微服务 vs 单体系统"></a>微服务 vs 单体系统</h3><h4 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h4><ul>
<li>微服务架构将单个服务对应到单个业务功能，方便理解、开发和维护。</li>
<li>其次，服务独立部署，可以根据每个服务的请求量来部署满足需求的规模；在需要添加新功能的时候，可以独立进行开发，随时更新、部署，不会影响其他线上的服务。</li>
</ul>
<h4 id="单体系统"><a href="#单体系统" class="headerlink" title="单体系统"></a>单体系统</h4><ul>
<li>单体应用将系统所有的逻辑都放到一起，所有的功能模块都整合在一起，逻辑复杂，代码臃肿，任何一个模块出现异常，都可能会导致应用服务器宕机；一旦系统需要扩展，不管是功能扩展还是性能扩展，对于单体系统难度都很大，尤其是性能扩展，只能把整个单体应用复制到多态服务器上。</li>
</ul>
<h3 id="微服务的特性"><a href="#微服务的特性" class="headerlink" title="微服务的特性"></a>微服务的特性</h3><ul>
<li>服务组件化</li>
<li>按业务组织团队</li>
<li>做产品的态度</li>
<li>轻量化通信机制</li>
<li>去中心化治理</li>
<li>去中心化管理数据</li>
<li>基础设施自动化</li>
<li>容错设计</li>
<li>演进式设计</li>
</ul>
<h3 id="微服务面临的挑战"><a href="#微服务面临的挑战" class="headerlink" title="微服务面临的挑战"></a>微服务面临的挑战</h3><h4 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h4><ul>
<li>将单体应用拆分为服务之后，需要对服务进行高效的管理，才能保证服务正常的运行，系统也才能为用户提供稳定的服务。</li>
</ul>
<h4 id="服务通信"><a href="#服务通信" class="headerlink" title="服务通信"></a>服务通信</h4><ul>
<li>微服务中不再像单体应用中一样，可以直接进行调用。服务之间需要进行网络通信。<strong>需要考虑服务之间如何高效地进行通信。</strong></li>
</ul>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><ul>
<li>负载均衡是微服务架构中必须使用的技术，通过负载均衡才可以实现系统的高可用、服务集群化等优化性能。</li>
</ul>
<h4 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h4><ul>
<li>每个微服务在通信中都需要实现认证、权限控制和日志等通用网关功能，且通信协议多样，导致客户端复杂笨重；需要引入服务网关支持。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/" class="category-chain-item">服务开发技术</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/" class="print-no-link">#服务开发技术</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>服务开发技术期末复习</div>
      <div>https://sdueryrg.github.io/2025/06/03/服务开发技术期末复习/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>yrg</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年6月3日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - yrg">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/06/09/%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E5%BE%80%E5%B9%B4%E9%A2%98%E6%B1%87%E6%80%BB/" title="服务开发往年题汇总">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">服务开发往年题汇总</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/05/28/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E5%8F%AF%E8%83%BD%E5%87%BA%E7%9A%84%E9%97%AE%E7%AD%94/" title="数据仓库可能出的问答">
                        <span class="hidden-mobile">数据仓库可能出的问答</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"9Ppdlu2us0WGqUfcIfWDrqWH-gzGzoHsz","appKey":"keWPwFcwx4yGF2QANdg94FGC","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  



  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
