<hr>
<h2 id="title-软件测试复习大纲date-2025-06-17-19-27-53tags"><a href="#title-软件测试复习大纲date-2025-06-17-19-27-53tags" class="headerlink" title="title: 软件测试复习大纲date: 2025-06-17 19:27:53tags:"></a>title: 软件测试复习大纲<br>date: 2025-06-17 19:27:53<br>tags:</h2><h1 id="软件测试复习大纲"><a href="#软件测试复习大纲" class="headerlink" title="软件测试复习大纲"></a>软件测试复习大纲</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="软件测试学科的发展"><a href="#软件测试学科的发展" class="headerlink" title="&#x2F;&#x2F;软件测试学科的发展"></a>&#x2F;&#x2F;软件测试学科的发展</h3><h4 id="4个导向"><a href="#4个导向" class="headerlink" title="4个导向"></a>4个导向</h4><ul>
<li>1957年之前，调试为主 (Debugging Oriented)</li>
<li>1957～1978年，以功能验证为导向，测试是证明软件是正确的（正向思维）。</li>
<li>1978～1983年，以破坏性检测为导向，测试是为了找到软件中的错误（逆向思维）。</li>
<li>1983～1987年，以质量评估为导向，测试是提供产品的评估和质量度量。</li>
<li>1988年起，以缺陷预防为导向，测试是为了展示软件符合设计要求，发现缺陷、预防缺陷。</li>
</ul>
<h4 id="不同阶段"><a href="#不同阶段" class="headerlink" title="不同阶段"></a>不同阶段</h4><p>初级阶段（1957～1971）测试通常被认为是对产品进行事后检验 ，缺乏有效的测试方法<br>发展阶段（1972～1982），1972年第一次关于软件测试的正式会议，促进了软件测试的发展<br>成熟阶段（1983到现在），国际标准Std 829-1983 ，形成一门独立的学科和专业，成为软件工程学科中的一个重要组成部分 </p>
<h3 id="正向测试与反向测试的定义，关系"><a href="#正向测试与反向测试的定义，关系" class="headerlink" title="正向测试与反向测试的定义，关系"></a>正向测试与反向测试的定义，关系</h3><h4 id="正向思维"><a href="#正向思维" class="headerlink" title="正向思维"></a>正向思维</h4><ul>
<li>测试是为了验证软件是否符合用户需求，即验证软件产品是否能正常工作</li>
</ul>
<h4 id="反向思维"><a href="#反向思维" class="headerlink" title="反向思维"></a>反向思维</h4><ul>
<li>测试是为了证明程序有错，而不是证明程序无错误</li>
</ul>
<h3 id="从从经济视角认知软件测试"><a href="#从从经济视角认知软件测试" class="headerlink" title="从从经济视角认知软件测试"></a>从从经济视角认知软件测试</h3><ul>
<li>测试的经济观点就是以最小的代价获得最高的软件产品质量。</li>
</ul>
<h3 id="SQA，与软件测试关系"><a href="#SQA，与软件测试关系" class="headerlink" title="SQA，与软件测试关系"></a>SQA，与软件测试关系</h3><h4 id="SQA"><a href="#SQA" class="headerlink" title="SQA"></a>SQA</h4><ul>
<li>软件质量保证（Software Quality Assurance，SQA）活动是通过对软件产品有计划的进行评审和审计来验证软件是否合乎标准的系统工程，通过协调、审查和跟踪以获取有用信息，形成分析结果以指导软件过程。</li>
</ul>
<h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><ul>
<li>SQA指导、监督软件测试的计划和执行，督促测试工作的结果客观、准确和有效，并协助测试流程的改进。</li>
<li>软件测试是SQA重要手段之一，为SQA提供所需的数据，作为质量评价的客观依据。</li>
<li>SQA是一项管理工作，侧重于对流程的评审和监控</li>
<li>测试是一项技术性的工作，侧重对产品进行评估和验证</li>
</ul>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="缺陷定义，现象，判定准则"><a href="#缺陷定义，现象，判定准则" class="headerlink" title="缺陷定义，现象，判定准则"></a>缺陷定义，现象，判定准则</h3><h4 id="软件缺陷"><a href="#软件缺陷" class="headerlink" title="软件缺陷"></a>软件缺陷</h4><ul>
<li>从产品内部看，软件缺陷是软件产品开发或维护过程中所存在的错误、毛病等各种问题；</li>
<li>从外部看，软件缺陷是系统所需要实现的某种功能的失效或违背。</li>
</ul>
<h4 id="软件缺陷的现象"><a href="#软件缺陷的现象" class="headerlink" title="软件缺陷的现象"></a>软件缺陷的现象</h4><ul>
<li>功能、特性没有实现或部分实现</li>
<li>设计不合理，存在缺陷</li>
<li>实际结果和预期结果不一致</li>
<li>运行出错，包括运行中断、系统崩溃、界面混乱</li>
<li>数据结果不正确、精度不够</li>
<li>用户不能接受的其他问题，如存取时间过长、界面不美观</li>
</ul>
<h4 id="判定准则"><a href="#判定准则" class="headerlink" title="判定准则"></a>判定准则</h4><ul>
<li>将被测试系统的实际输出与所期望的输出进行比较，从而判断是否有差异，即是否为缺陷</li>
</ul>
<h3 id="软件缺陷产生的原因有哪？"><a href="#软件缺陷产生的原因有哪？" class="headerlink" title="软件缺陷产生的原因有哪？"></a>软件缺陷产生的原因有哪？</h3><h4 id="技术问题"><a href="#技术问题" class="headerlink" title="技术问题"></a>技术问题</h4><ul>
<li>算法错误、计算和精度问题</li>
<li>接口参数传递不匹配</li>
</ul>
<h4 id="团队工作"><a href="#团队工作" class="headerlink" title="团队工作"></a>团队工作</h4><ul>
<li>沟通不充分，误解</li>
</ul>
<h4 id="软件本身"><a href="#软件本身" class="headerlink" title="软件本身"></a>软件本身</h4><ul>
<li>文档错误、用户使用场合(user scenario)，</li>
<li>时间上不协调、或不一致性所带来的问题</li>
<li>系统的自我恢复或数据的异地备份、灾难性恢复等问题</li>
</ul>
<h3 id="产品质量的内容，内部，外部，使用质量"><a href="#产品质量的内容，内部，外部，使用质量" class="headerlink" title="产品质量的内容，内部，外部，使用质量"></a>产品质量的内容，内部，外部，使用质量</h3><h4 id="产品质量"><a href="#产品质量" class="headerlink" title="产品质量"></a>产品质量</h4><ul>
<li>是人们实践产物的属性和行为，是可以认识，可以科学地描述的。并且可以通过一些方法和人类活动，来改进质量</li>
</ul>
<h4 id="内部质量→外部质量→使用质量"><a href="#内部质量→外部质量→使用质量" class="headerlink" title="内部质量→外部质量→使用质量"></a>内部质量→外部质量→使用质量</h4><p><img src="/%E5%86%85%E5%A4%96%E4%BD%BF%E7%94%A8%E8%B4%A8%E9%87%8F.png" alt="内外使用质量"></p>
<h3 id="如何理解软件规格说明书缺陷"><a href="#如何理解软件规格说明书缺陷" class="headerlink" title="如何理解软件规格说明书缺陷"></a>如何理解软件规格说明书缺陷</h3><h3 id="verification-validation"><a href="#verification-validation" class="headerlink" title="verification,validation"></a>verification,validation</h3><ul>
<li>软件测试是由“验证（Verification）”和“有效性确认（Validation）”活动构成的整体</li>
<li>Verification：Are we building the product right？是否正确地构造了软件？即是否正确地做事，验证开发过程是否遵守已定义好的内容。验证产品满足规格设计说明书的一致性</li>
<li>Validation： Are we building the right product? 是否构造了正是用户所需要的软件？即是否正在做正确的事。验证产品所实现的功能是否满足用户的需求</li>
</ul>
<h3 id="软件测试不同层次测试的对象和任务"><a href="#软件测试不同层次测试的对象和任务" class="headerlink" title="软件测试不同层次测试的对象和任务"></a>软件测试不同层次测试的对象和任务</h3><p><img src="/%E4%B8%8D%E5%90%8C%E5%B1%82%E6%AC%A1%E4%BB%BB%E5%8A%A1.png" alt="不同层次任务"></p>
<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><ul>
<li>单元测试针对程序系统中的最小单元—模块或组件进行测试，一般和编码同步进行。主要采用白盒测试方法，从程序的内部结构出发设计测试用例，检查程序模块或组件的已实现的功能与定义的功能是否一致、以及编码中是否存在错误。通常要编写驱动模块和桩模块</li>
</ul>
<h4 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h4><ul>
<li>集成测试，也称联调，在单元测试的基础上，将模块按照设计要求组装起来同时进行测试，主要目标是发现与接口有关的模块之间问题。现在提倡持续集成测试</li>
</ul>
<h4 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h4><ul>
<li><p>系统功能测试</p>
<ul>
<li>一般在完成集成测试后进行系统功能测试，而且基于产品功能说明书，针对产品所实现的功能，从用户角度来进行功能验证，以确认每个功能是否都能正常使用</li>
</ul>
</li>
<li><p>系统非功能测试</p>
<ul>
<li>系统非功能性测试是将软件放在整个计算机环境下，包括软硬件平台、某些支持软件和数据等，在实际运行环境下验证系统的非功能性，</li>
</ul>
</li>
</ul>
<h4 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h4><ul>
<li>验收测试的目的是向未来的用户表明系统能够像预定要求那样工作，验证软件的功能和性能如同用户所合理期待的那样</li>
</ul>
<h3 id="静态测试的内容包括什么？开展相关活动时采用的形式有哪些？"><a href="#静态测试的内容包括什么？开展相关活动时采用的形式有哪些？" class="headerlink" title="静态测试的内容包括什么？开展相关活动时采用的形式有哪些？"></a>静态测试的内容包括什么？开展相关活动时采用的形式有哪些？</h3><ul>
<li>静态测试包括对软件产品的需求和设计文档、代码的评审（技术评审、文档评审等），以及对代码的静态分析等；</li>
<li>管理评审、流程评审不属于静态测试，而是属于质量保证（QA）；</li>
<li>评审的主要形式：互为评审 (Peer review)、走查 (walk-through)、会议评审 (Inspection)；</li>
<li>代码的静态分析主要采用工具进行，但人工的代码评审也不可或缺。</li>
</ul>
<h3 id="测试工作的流程"><a href="#测试工作的流程" class="headerlink" title="测试工作的流程"></a>测试工作的流程</h3><p><img src="/%E8%BD%AF%E6%B5%8B%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="软测工作流程"></p>
<h3 id="软件测试的工作范畴"><a href="#软件测试的工作范畴" class="headerlink" title="软件测试的工作范畴"></a>软件测试的工作范畴</h3><ul>
<li>测试需求分析、测试策略指定、测试计划、测试设计、测试执行、测试结果和过程评估</li>
</ul>
<h4 id="测试需求分析"><a href="#测试需求分析" class="headerlink" title="测试需求分析"></a>测试需求分析</h4><ul>
<li>明确测试范围，了解哪些功能点要测试、哪些功能点不需要测试；</li>
<li>知道哪些测试目标优先级高、哪些目标优先级低；</li>
<li>要完成哪些相应的测试任务才能确保目标的实现。</li>
</ul>
<h4 id="测试策略指定"><a href="#测试策略指定" class="headerlink" title="测试策略指定"></a>测试策略指定</h4><ul>
<li>基于下列这些因素的考虑做出决定：<ul>
<li>测试方式，包括手工方式与自动化方式、静态方式与动态方式等的选择与平衡，探索式测试或基于脚本的测试、自己团队测试还是众测、外包等平衡；</li>
<li>测试方法，包括黑盒测试还是白盒测试方法、基于数据流还是基于控制流的方法、完全组合测试方法还是组合优化测试方法等平衡；</li>
<li>测试过程，先测什么、后测试什么，对测试阶段的不同划分等。</li>
</ul>
</li>
</ul>
<h4 id="测试计划"><a href="#测试计划" class="headerlink" title="测试计划"></a>测试计划</h4><h4 id="测试设计"><a href="#测试设计" class="headerlink" title="测试设计"></a>测试设计</h4><ul>
<li>是解决“如何测”的问题，可以分为测试总体设计和测试详细设计:<ul>
<li>测试总体设计则主要指测试方案的设计、测试结构的设计</li>
<li>测试详细设计主要是指测试用例的设计。</li>
</ul>
</li>
</ul>
<h4 id="测试执行"><a href="#测试执行" class="headerlink" title="测试执行"></a>测试执行</h4><ul>
<li>手工执行：基于详细设计的测试用例来完成测试，也可以在没有测试用例的情况下进行的探索式测试。</li>
<li>自动化执行：指采用测试工具来完成，一般都需要开发自动化测试脚本，然后工具执行脚本，在后续“单元测试与集成测试、系统测试和自动化测试框架”等各章会进行详细讨论。</li>
</ul>
<h4 id="测试结果和过程评估"><a href="#测试结果和过程评估" class="headerlink" title="测试结果和过程评估"></a>测试结果和过程评估</h4><ul>
<li>测试结果评估：对测试结果进行分析，如分析测试覆盖率，以了解测试是否充分；也可以基于缺陷的趋势分析和分布分析，了解缺陷是否已收敛，以及基于缺陷来评估当前被测试的版本的质量 。</li>
<li>测试过程评估，结合测试计划来进行评审，相当于把计划的测试活动和实际执行的活动进行比较，了解测试计划执行的情况和效果 。</li>
</ul>
<h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="等价类"><a href="#等价类" class="headerlink" title="等价类"></a>等价类</h3><h3 id="边界值法"><a href="#边界值法" class="headerlink" title="边界值法"></a>边界值法</h3><h3 id="决策表，因果图法"><a href="#决策表，因果图法" class="headerlink" title="决策表，因果图法"></a>决策表，因果图法</h3><h3 id="各种逻辑覆盖法"><a href="#各种逻辑覆盖法" class="headerlink" title="各种逻辑覆盖法"></a>各种逻辑覆盖法</h3><h3 id="路径覆盖法"><a href="#路径覆盖法" class="headerlink" title="路径覆盖法"></a>路径覆盖法</h3><h3 id="功能图法，EFMS"><a href="#功能图法，EFMS" class="headerlink" title="功能图法，EFMS"></a>功能图法，EFMS</h3><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="测试左移和右移，贯穿全生命周期的测试思想"><a href="#测试左移和右移，贯穿全生命周期的测试思想" class="headerlink" title="测试左移和右移，贯穿全生命周期的测试思想"></a>测试左移和右移，贯穿全生命周期的测试思想</h3><h4 id="测试左移和右移"><a href="#测试左移和右移" class="headerlink" title="测试左移和右移"></a>测试左移和右移</h4><ul>
<li>测试左移：不仅让开发人员做更多的测试，而且需要做需求评审、设计评审，以及第1章介绍的验收测试驱动开发（ATDD）；</li>
<li>测试右移：是在线测试（Test in Production，TiP），包括在线性能监控与分析、A&#x2F;B测试和日志分析等，可以和现在流行的DevOp联系起来。</li>
</ul>
<h4 id="软件测试生命周期"><a href="#软件测试生命周期" class="headerlink" title="软件测试生命周期"></a>软件测试生命周期</h4><p><img src="/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="软件测试生命周期"></p>
<h3 id="w模型"><a href="#w模型" class="headerlink" title="w模型"></a>w模型</h3><p><img src="/W%E6%A8%A1%E5%9E%8B.png" alt="W模型"></p>
<ul>
<li>测试过程和开发是同时开始同时结束的，两者是同步关系</li>
<li>测试过程是对开发过程中的阶段性成果和最终的产品进行验证的过程，两者相互依赖<ul>
<li>前期测试更多依赖开发，后期反过来</li>
</ul>
</li>
</ul>
<h3 id="TMAP定义，几个阶段，模型基石及关系"><a href="#TMAP定义，几个阶段，模型基石及关系" class="headerlink" title="TMAP定义，几个阶段，模型基石及关系"></a>TMAP定义，几个阶段，模型基石及关系</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>TMap (Test Management Approach，测试管理方法)是一种结构化的、基于风险策略的测试方法体系, 目的能更早地发现缺陷，以最小的成本、有效地、彻底地完成测试任务，以减少软件发布后的支持成本。</li>
<li>TMap所定义的测试生命周期由计划和控制、准备、说明、执行和完成等阶段组成</li>
</ul>
<h4 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h4><p><img src="/TMap%E9%98%B6%E6%AE%B5.png" alt="TMap阶段"></p>
<h4 id="基石"><a href="#基石" class="headerlink" title="基石"></a>基石</h4><p><img src="/TMAP%E5%9F%BA%E7%9F%B3.png" alt="TMAP基石"></p>
<h3 id="SBTM基本要素，结果，原理"><a href="#SBTM基本要素，结果，原理" class="headerlink" title="SBTM基本要素，结果，原理"></a>SBTM基本要素，结果，原理</h3><h4 id="要素"><a href="#要素" class="headerlink" title="要素"></a>要素</h4><ul>
<li>Session(会话)是一段不受打扰的测试时间（通常是90分钟），是测试管理的最小单元。<ul>
<li>每个session关联一个特定的、目标明确的测试任务（mission）</li>
</ul>
</li>
<li>Charter (章程，即测试指导) ：对每个session如何执行进行简要的描述，相当于每个session需要一个简要的计划（提纲）<ul>
<li>一系列Session相互支持，有机地组合在一起，周密地测试了整个产品。</li>
</ul>
</li>
<li>A session sheet (测试报告) ： 相当于测试报告，供第三方（如测试经理、ScrumMaster等）进行检查的材料。它最好能被工具扫描、解析和合成。</li>
<li>Debriefing（听取口头报告）：口头汇报，更准确地说，是测试人和其lead&#x2F;Manager之间的对话。</li>
</ul>
<h4 id="结果：Session-Sheet"><a href="#结果：Session-Sheet" class="headerlink" title="结果：Session Sheet"></a>结果：Session Sheet</h4><ul>
<li>Session charter (包含任务陈述、测试范围等)</li>
<li>Tester name(s)&#x2F;测试执行者</li>
<li>Task breakdown :TBS（Test&#x2F;Bug&#x2F;Setup）度量（耗时），这些数据配合简报有助于估算测试速度、评估测试效率</li>
<li>测试数据、数据文件：为测试数据复用提供了基础</li>
<li>Note&#x2F; 测试笔记：测试过程中随时记录的有价值的信息，叙述了测试故事：为什么测试，如何测，为什么这样的测试已足够好</li>
<li>Issues&#x2F; 问题&#x2F;风险：测试过程中的问题和疑惑（未来测试的参考资料）</li>
<li>缺陷：测试的直接产出</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li>通过结构化的测试会话来组织和管理探索性测试活动，以提高测试效率和质量。</li>
</ul>
<h3 id="测试几个学派的特点"><a href="#测试几个学派的特点" class="headerlink" title="测试几个学派的特点"></a>测试几个学派的特点</h3><ul>
<li>分析流派：认为测试是严格的和技术性的，在学术界有许多支持者</li>
<li>标准流派：将测试视为衡量进度的一种方法，强调成本和可重复的标准</li>
<li>质量流派：强调过程规范性，监督开发人员并充当质量的看门人</li>
<li>上下文驱动流派：强调人的价值，寻找涉众关心的bug</li>
<li>敏捷流派：强调自动化测试，使用测试来快速验证开发是完整的</li>
</ul>
<h3 id="TMM，TPI，CTP-STEP定义，特点"><a href="#TMM，TPI，CTP-STEP定义，特点" class="headerlink" title="TMM，TPI，CTP, STEP定义，特点"></a>TMM，TPI，CTP, STEP定义，特点</h3><h4 id="TMMi-Testing-Maturity-Model-integration"><a href="#TMMi-Testing-Maturity-Model-integration" class="headerlink" title="TMMi(Testing Maturity Model integration)"></a>TMMi(Testing Maturity Model integration)</h4><ul>
<li>测试成熟度模型集成</li>
<li>过程能力描述了遵循一个软件测试过程可能达到的预期结果的范围。TMMi的建立，得益于以下3点：<ul>
<li>充分吸收、CMM&#x2F;CMMi的精华；</li>
<li>基于历史演化的测试过程；</li>
<li>业界的最佳实践。</li>
</ul>
</li>
<li>5个别级的一系列测试能力成熟度的定义，每个级别的组成包括到期目标、到期子目标活动、任务和职责等。</li>
<li>一套评价模型，包括一个成熟度问卷、评估程序和团队选拔培训指南。 </li>
<li>2-5级别内容<br><img src="/TMMi.png" alt="TMMi"></li>
</ul>
<h4 id="TPI-Test-Process-Improvement"><a href="#TPI-Test-Process-Improvement" class="headerlink" title="TPI(Test Process Improvement)"></a>TPI(Test Process Improvement)</h4><h5 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h5><ul>
<li>是基于连续性表示法的测试过程改进的参考模型，是在软件控制、测试知识以及过往经验的基础上开发出来的<br><img src="/TPI.png" alt="TPI"></li>
<li>20个关键域<br><img src="/TPI%E5%85%B3%E9%94%AE%E5%9F%9F.png" alt="TPI关键域"></li>
</ul>
<h5 id="TPI级别"><a href="#TPI级别" class="headerlink" title="TPI级别"></a>TPI级别</h5><ul>
<li>为了了解过程在每个关键域所处的状态，即对关键域的评估结果，通过级别是来体现。模型提供了4个级别，由A到D，A是最低级。根据测试过程的可视性改善、测试效率的提高、或成本的降低以及质量的提高，级别会有所上升。</li>
</ul>
<h5 id="TPI检查点和建议"><a href="#TPI检查点和建议" class="headerlink" title="TPI检查点和建议"></a>TPI检查点和建议</h5><ul>
<li>为了能客观地决定各个关键域的级别，TPI模型提供了一种度量工具——检查点。每个级别都有若干个检查点，测试过程只有在满足了这些检查点的要求之后，才意味着它达到了特定的级别</li>
<li>检查点帮助我们发现测试过程中的问题，而建议会帮助我们解决问题，最终改进测试过程。建议不仅包含对如何达到下个级别的指导，而且还包括一些具体的操作技巧、注意事项等。</li>
</ul>
<h5 id="TPI-NEXT"><a href="#TPI-NEXT" class="headerlink" title="TPI NEXT"></a>TPI NEXT</h5><ul>
<li>商业驱动作为测试过程提升的基础</li>
<li>为改进目标和度量设定优先级</li>
<li>确保商业可以引导和控制改进的过程</li>
</ul>
<h4 id="CTP-Critical-Test-Process-关键测试过程"><a href="#CTP-Critical-Test-Process-关键测试过程" class="headerlink" title="CTP(Critical Test Process)关键测试过程"></a>CTP(Critical Test Process)关键测试过程</h4><h5 id="定义和内容"><a href="#定义和内容" class="headerlink" title="定义和内容"></a>定义和内容</h5><ul>
<li>内容参考模型、上下文相关的方法，并能对模型进行裁剪</li>
<li>使用CTP的过程改进，始于对现有测试过程的评估，通过评估以识别过程的强弱，并结合组织的需要提供改进的意见</li>
<li>计划（Plan）、准备（Prepare）、执行（Perform）和完善 (Perfect)；计划和完善主要是管理工作，准备和执行是实践工作</li>
</ul>
<h5 id="CTP的12个关键过程"><a href="#CTP的12个关键过程" class="headerlink" title="CTP的12个关键过程"></a>CTP的12个关键过程</h5><ul>
<li>测试</li>
<li>建立上下文关系和测试环境</li>
<li>质量风险评估</li>
<li>测试估算</li>
<li>测试计划</li>
<li>测试团队开发</li>
<li>测试（管理）系统开发</li>
<li>测试发布管理</li>
<li>测试执行</li>
<li>缺陷报告</li>
<li>测试结果报告</li>
<li>变更管理</li>
</ul>
<h4 id="STEP-Systematic-Test-and-Evaluation-Process，系统化测试和评估过程"><a href="#STEP-Systematic-Test-and-Evaluation-Process，系统化测试和评估过程" class="headerlink" title="STEP(Systematic Test and Evaluation Process，系统化测试和评估过程)"></a>STEP(Systematic Test and Evaluation Process，系统化测试和评估过程)</h4><h5 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h5><ul>
<li>是一个内容参考模型</li>
<li>基于需求的测试策略</li>
<li>在生命周期初始开始进行测试</li>
<li>测试用作需求和使用模型 </li>
<li>由测试件设计导出软件设计（测试驱动开发）</li>
<li>及早发现缺陷或完全的缺陷预防</li>
<li>对缺陷进行系统分析</li>
<li>测试人员和开发人员一起工作</li>
</ul>
<h5 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h5><ul>
<li>STEP与CTP比较类似，而不像TMMI和TPI，并不要求改进需要遵循特定的顺序。</li>
<li>某些情况下，STEP评估模型可以与TPI成熟度模型结合起来使用</li>
</ul>
<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="代码评审的形式及各自特点"><a href="#代码评审的形式及各自特点" class="headerlink" title="代码评审的形式及各自特点"></a>代码评审的形式及各自特点</h3><h4 id="互查"><a href="#互查" class="headerlink" title="互查"></a>互查</h4><ul>
<li>自由，不正式，容易开展，开发人员互相审查彼此编码</li>
</ul>
<h4 id="走查"><a href="#走查" class="headerlink" title="走查"></a>走查</h4><ul>
<li>相对正式，采用讲解、讨论和模拟运行方式进行查找错误的活动</li>
</ul>
<h4 id="会议评审"><a href="#会议评审" class="headerlink" title="会议评审"></a>会议评审</h4><ul>
<li>以会议的形式，制定目标，流程和规则</li>
</ul>
<h3 id="单元测试定义，作用，目标"><a href="#单元测试定义，作用，目标" class="headerlink" title="单元测试定义，作用，目标"></a>单元测试定义，作用，目标</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li>单元测试是对软件基本组成单元（如函数、类的方法等）进行的测试。</li>
</ul>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li>单元质量是系统质量的基石，单元测试可以比系统测试测得更彻底</li>
</ul>
<h4 id="单元测试的目标"><a href="#单元测试的目标" class="headerlink" title="单元测试的目标"></a>单元测试的目标</h4><ul>
<li>单元模块被正确编码	</li>
<li>信息能否正确地流入和流出单元；</li>
<li>在单元工作过程中，其内部数据能否保持其完整性，包括内部数据的形式、内容及相互关系不发生错误，也包括全局变量在单元中的处理和影响。 </li>
<li>在为限制数据加工而设置的边界处，能否正确工作。</li>
<li>单元的运行能否做到满足特定的逻辑覆盖。 </li>
<li>单元中发生了错误，其中的出错处理措施是否有效。</li>
</ul>
<blockquote>
<p>单元模块被正确实现（主要指编码），包括功能、性能、安全性等，但一般主要介绍单元功能测试。<br>（参数）输入是否正确传递和得到保护（容错），输出是否正常<br>内部数据能否保持其完整性，包括变量的正确定义与引用、内存及时释放、全局变量的正确处理和影响最低<br>代码行、分支覆盖或MC&#x2F;DC达到要求，如高于80%或95%</p>
</blockquote>
<h3 id="桩程序，驱动程序"><a href="#桩程序，驱动程序" class="headerlink" title="桩程序，驱动程序"></a>桩程序，驱动程序</h3><ul>
<li>驱动程序（Driver）也称作驱动模块，用以模拟被测模块的上级模块，能够调用被测模块。在测试过程中，驱动模块接收测试数据，调用被测模块并把相关的数据传送给被测模块。</li>
</ul>
<blockquote>
<p>简单说就是你负责测试的模块没有main()方法入口，所以需要写一个带main的方法来调用你的模块或方法。这个就是驱动测试</p>
</blockquote>
<ul>
<li>桩程序（Stub），也称桩模块，用以模拟被测模块工作过程中所调用的下层模块。桩模块由被测模块调用，它们一般只进行很少的数据处理。<blockquote>
<p>这里解释一下桩，桩是指用来代替关联代码或者未实现的代码。如果函数B用B1来代替，那么，B称为原函数，B1称为桩函数。打桩就是编写或生成桩代码。</p>
</blockquote>
</li>
</ul>
<h3 id="集成测试的概念"><a href="#集成测试的概念" class="headerlink" title="集成测试的概念"></a>集成测试的概念</h3><ul>
<li>集成测试是将软件集成起来，对模块之间的接口进行测试。 </li>
<li>顾名思义，集成测试是将软件集成起来后进行测试。集成测试又叫子系统测试、组装测试、部件测试等。<ul>
<li>模块内的集成，主要是测试模块内各个接口间的交互集成关系；</li>
<li>子系统内的集成，测试子系统内各个模块间的交互关系；</li>
<li>系统内的集成，测试系统内各个子系统和模块间的集成关系。</li>
</ul>
</li>
<li>集成测试的测试依据；概要设计书，详细设计说明书，主要是概要设计说明书</li>
</ul>
<h3 id="单一系统的集成测试的集成模式及优缺点"><a href="#单一系统的集成测试的集成模式及优缺点" class="headerlink" title="单一系统的集成测试的集成模式及优缺点"></a>单一系统的集成测试的集成模式及优缺点</h3><h4 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h4><ul>
<li>定义：从系统的顶层模块开始，逐步向下集成和测试。</li>
<li>优点：<ul>
<li>测试早期即可验证系统的主要控制逻辑。</li>
<li>测试驱动程序较少，减少开发工作量。</li>
</ul>
</li>
<li>缺点：<ul>
<li>需要大量桩程序来模拟底层模块。</li>
<li>底层模块的测试可能被延迟。</li>
</ul>
</li>
</ul>
<h4 id="自底向上"><a href="#自底向上" class="headerlink" title="自底向上"></a>自底向上</h4><ul>
<li>定义：从系统的底层模块开始，逐步向上集成和测试。</li>
<li>优点：<ul>
<li>底层模块的测试可以尽早完成。</li>
<li>桩程序需求较少。</li>
</ul>
</li>
<li>缺点：<ul>
<li>需要开发大量驱动程序来调用底层模块。</li>
<li>系统的整体功能验证可能被延迟。</li>
</ul>
</li>
</ul>
<h4 id="混合策略"><a href="#混合策略" class="headerlink" title="混合策略"></a>混合策略</h4><ul>
<li>定义：同时从顶层和底层开始集成，最后在中间层完成集成。</li>
<li>优点：<ul>
<li>顶层和底层模块可以同时测试，节省时间。</li>
<li>减少桩程序和驱动程序的开发工作量。</li>
</ul>
</li>
<li>缺点：<ul>
<li>需要协调顶层和底层模块的集成进度。</li>
<li>中间层模块的测试可能较复杂。</li>
</ul>
</li>
</ul>
<h3 id="微服务特点，测试目标？测试基本步骤？"><a href="#微服务特点，测试目标？测试基本步骤？" class="headerlink" title="&#x2F;&#x2F;微服务特点，测试目标？测试基本步骤？"></a>&#x2F;&#x2F;微服务特点，测试目标？测试基本步骤？</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>模块化</li>
<li>独立部署</li>
<li>分布式架构</li>
</ul>
<h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ul>
<li>验证服务功能</li>
<li>接口测试</li>
<li>性能测试</li>
<li>容错测试</li>
<li>集成测试</li>
<li>安全性测试</li>
<li>兼容性测试</li>
</ul>
<h3 id="集成测试的目标"><a href="#集成测试的目标" class="headerlink" title="集成测试的目标"></a>集成测试的目标</h3><ul>
<li>集成测试，也叫组装测试或联合测试。在单元测试的基础上，将所有模块按照设计要求（如根据结构图〕组装成为子系统或系统，进行集成测试。实践表明，一些模块虽然能够单独地工作，但并不能保证连接起来也能正常的工作。程序在某些局部反映不出来的问题，在全局上很可能暴露出来，影响功能的实现。</li>
<li>目标在于检验与软件设计相关的程序结构问题。如数据穿过接口时可能丢失；一个模块与另一个模块可能有由于疏忽的问题而造成有害影响； 把子功能组合起来可能不产生预期的主功能；个别看起来是可以接受的误差可能积累到不能接受的程度；全程数据结构可能有错误等。</li>
</ul>
<h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><h3 id="功能测试的基本思路"><a href="#功能测试的基本思路" class="headerlink" title="功能测试的基本思路"></a>功能测试的基本思路</h3><p><img src="/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF.png" alt="功能测试的基本思路"></p>
<h3 id="回归测试需要解决的问题。回归测试的策略和方法"><a href="#回归测试需要解决的问题。回归测试的策略和方法" class="headerlink" title="回归测试需要解决的问题。回归测试的策略和方法"></a>回归测试需要解决的问题。回归测试的策略和方法</h3><h4 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h4><ul>
<li>回归缺陷：原来正常工作的功能，没有发生需求变化，而由于受其它改动影响而产生的问题。</li>
<li>回归测试就是为了发现回归缺陷而进行的测试。如果没有回归测试，产品就带着回归缺陷被发布出去了，造成严重后果。</li>
</ul>
<h4 id="回归测试策略"><a href="#回归测试策略" class="headerlink" title="回归测试策略"></a>回归测试策略</h4><ul>
<li>再测试全部用例	</li>
<li>基于风险选择测试</li>
<li>基于操作剖面选择测试	</li>
<li>再测试修改的部分</li>
</ul>
<h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><h3 id="性能测试目标"><a href="#性能测试目标" class="headerlink" title="性能测试目标"></a>性能测试目标</h3><ul>
<li>获取系统性能某些指标数据</li>
<li>为了验证系统是否达到用户提出的性能指标</li>
<li>发现系统中存在的性能瓶颈，优化系统的性能</li>
</ul>
<h3 id="什么是性能测试？"><a href="#什么是性能测试？" class="headerlink" title="什么是性能测试？"></a>什么是性能测试？</h3><ul>
<li>性能测试（performance test）就是为了发现系统性能问题或获取系统性能相关指标而进行的测试。一般在真实环境、特定负载条件下，通过工具模拟实际软件系统的运行及其操作，同时监控性能各项指标，最后对测试结果进行分析以确定系统的性能状况。</li>
</ul>
<h3 id="系统性能表现"><a href="#系统性能表现" class="headerlink" title="系统性能表现"></a>系统性能表现</h3><h4 id="外部表现"><a href="#外部表现" class="headerlink" title="外部表现"></a>外部表现</h4><ul>
<li>启动系统、打开页面越来越慢</li>
<li>查询数据，很长时间才显示列表</li>
<li>网络下载速度很低，如5k&#x2F;s</li>
</ul>
<h4 id="内因"><a href="#内因" class="headerlink" title="内因"></a>内因</h4><ul>
<li>资源耗尽,如CPU使用率达到100%</li>
<li>资源泄漏,如内存泄漏 ，最终会导致资源耗尽</li>
<li>资源瓶颈,如线程、GDI、DB连接等资源变得稀缺</li>
</ul>
<h3 id="按照测试目的分，性能测试类型"><a href="#按照测试目的分，性能测试类型" class="headerlink" title="按照测试目的分，性能测试类型"></a>按照测试目的分，性能测试类型</h3><ul>
<li>性能基准测试：在系统标准配置下获得有关的性能指标数据，作为将来性能改进的基线(Baseline)</li>
<li>性能验证测试：验证系统是否达到事先已定义的系统性能指标、能否满足系统的性能需求</li>
<li>性能规划测试：在多种特定的环境下，获得不同配置的系统性能指标，从而决定系统部署的软硬件配置选型</li>
<li>容量测试可以看作性能的测试一种，因为系统的容量可以看作是系统性能指标之一</li>
<li>压力测试 (Stress test) ：模拟实际应用的软硬件环境及用户使用过程的高负载、异常负载、超长时间运行，从而加速系统崩溃，以检查程序对异常情况的抵抗能力，找出性能瓶颈、不稳定等问题。</li>
<li>渗入测试（soak test），通过长时间运行，使问题逐渐渗透出来，从而发现内存泄漏、垃圾回收（GC）或系统的其他问题，以检验系统的健壮性</li>
<li>峰谷测试（peak-rest test），采用高低突变加载方式进行，先加载到高水平的负载，然后急剧降低负载，稍微平息一段时间，再加载到高水平的负载，重复这样过程，容易发现问题的蛛丝马迹，最终找到问题的根源</li>
</ul>
<h3 id="什么是压力测试"><a href="#什么是压力测试" class="headerlink" title="什么是压力测试"></a>什么是压力测试</h3><ul>
<li>模拟实际应用的软硬件环境及用户使用过程的高负载、异常负载、超长时间运行，从而加速系统崩溃，以检查程序对异常情况的抵抗能力，找出性能瓶颈、不稳定等问题。</li>
</ul>
<h3 id="性能测试的基本过程"><a href="#性能测试的基本过程" class="headerlink" title="性能测试的基本过程"></a>性能测试的基本过程</h3><p><img src="/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B.png" alt="性能测试的基本过程"></p>
<h3 id="什么是安全性测试"><a href="#什么是安全性测试" class="headerlink" title="什么是安全性测试"></a>什么是安全性测试</h3><ul>
<li>旨在评估系统的安全性，确保系统能够保护数据和资源免受未经授权的访问、使用、泄露、破坏或篡改。安全性测试的目标是发现系统中的安全漏洞，并验证安全机制的有效性。</li>
</ul>
<h3 id="渗透测试实施策略"><a href="#渗透测试实施策略" class="headerlink" title="渗透测试实施策略"></a>渗透测试实施策略</h3><ul>
<li>全程监控：采用类似wireshark的嗅探软件进行全程抓包嗅探</li>
<li>择要监控：对扫描过程不进行录制，仅仅在数据分析后，准备发起渗透前才开启软件进行嗅探</li>
<li>主机监控：仅监控受测主机的存活状态</li>
<li>指定攻击源：多方监控指定源（某主机）进程、网络连接、数据传输等</li>
<li>对关键系统，可以采用对目标的副本进行渗透测试</li>
</ul>
<h3 id="软件安全性测试有哪两种？有什么关系和区别？"><a href="#软件安全性测试有哪两种？有什么关系和区别？" class="headerlink" title="软件安全性测试有哪两种？有什么关系和区别？"></a>软件安全性测试有哪两种？有什么关系和区别？</h3><ul>
<li>安全功能测试 (Security Functional Testing)：数据机密性、完整性、可用性、不可否认性、身份认证、授权、访问控制、审计跟踪、委托、隐私保护、安全管理等</li>
<li>安全漏洞测试 (Security Vulnerability Testing)：从攻击者的角度, 以发现软件的安全漏洞为目的。安全漏洞是指系统在设计、实现、操作、管理上存在的可被利用的缺陷或弱点</li>
</ul>
<h3 id="安全性测试的任务"><a href="#安全性测试的任务" class="headerlink" title="安全性测试的任务"></a>安全性测试的任务</h3><ul>
<li>全面检验软件在需求规格说明中规定的防止危险状态措施的有效性和在每一个危险状态下的反应</li>
<li>对软件设计中用于提高安全性的结构、算法、容错、冗余、中断处理等方案，进行针对性测试</li>
<li>在异常条件下测试软件，以表明不会因可能的单个或多个输入错误而导致不安全状态</li>
<li>对安全性关键的软件单元、组件，单独进行加强的测试，以确认其满足安全性需求</li>
</ul>
<h3 id="安全性测试方法按内外部分为哪两种？"><a href="#安全性测试方法按内外部分为哪两种？" class="headerlink" title="安全性测试方法按内外部分为哪两种？"></a>安全性测试方法按内外部分为哪两种？</h3><h4 id="基于威胁的方法"><a href="#基于威胁的方法" class="headerlink" title="基于威胁的方法"></a>基于威胁的方法</h4><ul>
<li>从软件外部考察其安全性，识别软件面临的安全威胁并测试其是否能够发生</li>
</ul>
<h4 id="基于漏洞的方法"><a href="#基于漏洞的方法" class="headerlink" title="基于漏洞的方法"></a>基于漏洞的方法</h4><ul>
<li>从软件内部考虑其安全性，识别软件的安全漏洞，如借助特定的漏洞扫描工具</li>
</ul>
<h3 id="什么是XSS攻击和sql注入攻击，如何进行测试和防范"><a href="#什么是XSS攻击和sql注入攻击，如何进行测试和防范" class="headerlink" title="什么是XSS攻击和sql注入攻击，如何进行测试和防范"></a>什么是XSS攻击和sql注入攻击，如何进行测试和防范</h3><h4 id="XSS-跨站脚本攻击"><a href="#XSS-跨站脚本攻击" class="headerlink" title="XSS 跨站脚本攻击"></a>XSS 跨站脚本攻击</h4><ul>
<li>允许恶意用户将代码植入到“供其它用户使用的web页面” 中</li>
<li>输入验证：对用户输入进行严格的验证，拒绝恶意脚本。</li>
<li>输出编码：对动态生成的HTML内容进行编码，防止脚本执行。<ul>
<li>使用HTML实体编码，例如将&lt;编码为<code>&amp;lt;</code>。</li>
</ul>
</li>
</ul>
<h4 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h4><ul>
<li>根据SQL语句的编写规则，附加一个永远为“真”的条件，使系统中某个认证条件总是成立，从而欺骗系统、躲过认证，进而侵入系统 </li>
<li>使用参数化查询</li>
<li>限制数据库权限</li>
</ul>
<h3 id="web安全性测试可从哪些方法开展"><a href="#web安全性测试可从哪些方法开展" class="headerlink" title="web安全性测试可从哪些方法开展"></a>web安全性测试可从哪些方法开展</h3><ul>
<li>检查应用系统架构,防止用户绕过系统直接修改数据库</li>
<li>检查身份认证模块，用以防止非法用户绕过身份认证</li>
<li>检查数据库接口模块，用以防止用户获取系统权限</li>
<li>检查文件接口模块，防止用户获取系统文件</li>
<li>检查其他安全威胁</li>
</ul>
<h3 id="什么是软件可靠性？可从哪几个指标度量？各自的定义"><a href="#什么是软件可靠性？可从哪几个指标度量？各自的定义" class="headerlink" title="什么是软件可靠性？可从哪几个指标度量？各自的定义"></a>什么是软件可靠性？可从哪几个指标度量？各自的定义</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><ul>
<li>在规定的一段时间和条件下，软件能维持其性能水平的能力有关的一组属性，可用成熟性、容错性、易恢复性三个基本子特性来度量。</li>
<li>成熟性度量：通过错误发现率DDP（Defect Detection Percentage）来表现。DDP越小，软件越成熟。<ul>
<li>DDP&#x3D;测试发现的错误数量&#x2F;已知的全部错误数量</li>
</ul>
</li>
<li>容错性度量，容错测试是一种对抗性的测试过程。在这种测试中，通过各种手段让软件强制性地发生故障，或将把应用程序或系统置于（模拟的）异常条件下，以产生故障，例如设备输入&#x2F;输出（I&#x2F;O）故障或无效的数据库指针和关键字等 </li>
<li>恢复性度量，恢复性的测试先设法（模拟）使系统崩溃、失效等，然后计算其系统和数据恢复的时间来做出易恢复性评估。</li>
</ul>
<h3 id="容错测试的要点？"><a href="#容错测试的要点？" class="headerlink" title="容错测试的要点？"></a>容错测试的要点？</h3><ul>
<li>容错测试是一种对抗性的测试过程。在这种测试中，通过各种手段让软件强制性地发生故障，或将把应用程序或系统置于（模拟的）异常条件下，以产生故障，例如设备输入&#x2F;输出（I&#x2F;O）故障或无效的数据库指针和关键字等</li>
</ul>
<h3 id="什么是A-B测试？有什么特点"><a href="#什么是A-B测试？有什么特点" class="headerlink" title="什么是A&#x2F;B测试？有什么特点"></a>什么是A&#x2F;B测试？有什么特点</h3><ul>
<li>A&#x2F;B测试（ABTest） 是将用户分成不同的组，同时在线试验产品的不同版本，通过用户反馈的真实数据来确定哪一个方案更好</li>
<li>先验性：采用流量分割与小流量测试的方式，先让线上部分小流量用户使用以验证设计，再根据数据反馈来推广到全流量，减少产品损失</li>
<li>并行性：同时运行两个或两个以上版本的试验完成对比分析，而且保证每个版本所处的环境一致的，避免流程周期长的问题，节省验证时间</li>
<li>科学性：基于统计的数据来做出决策，避免主观或经验的错误决策</li>
</ul>
<h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><h3 id="软件本地化，国际化，全球化，相互关系"><a href="#软件本地化，国际化，全球化，相互关系" class="headerlink" title="软件本地化，国际化，全球化，相互关系"></a>软件本地化，国际化，全球化，相互关系</h3><h4 id="I18N国际化"><a href="#I18N国际化" class="headerlink" title="I18N国际化"></a>I18N国际化</h4><ul>
<li>支持Unicode字符集、双字节的字符；</li>
<li>分离程序代码和显示内容</li>
<li>消除Hard code</li>
<li>使用Header files 去定义经常被调用的代码段；</li>
<li>改善翻译文本尺寸，具有调整的灵活性</li>
<li>支持各个国家的键盘设置；</li>
<li>支持文字排序和大小写转换；</li>
<li>支持各个国家的度量衡，时区，货币单位格式等的设置；</li>
<li>国际化用户界面设计（自我定义）。</li>
</ul>
<h4 id="L10N本地化"><a href="#L10N本地化" class="headerlink" title="L10N本地化"></a>L10N本地化</h4><ul>
<li>翻译</li>
<li>地区文化、宗教</li>
<li>度量衡和时区等</li>
<li>软件用户界面（UI）</li>
<li>联机文档 (帮助文档和功能性的PDF文档) </li>
<li>热键设置</li>
</ul>
<h3 id="unicode与utf-x关系，特点"><a href="#unicode与utf-x关系，特点" class="headerlink" title="unicode与utf-x关系，特点"></a>unicode与utf-x关系，特点</h3><h4 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h4><ul>
<li>定义：Unicode是一种字符编码标准，旨在为全球所有语言的字符分配唯一的编码。它解决了不同语言和字符集之间的兼容性问题。</li>
<li>作用：Unicode定义了一个统一的字符集（字符的编号），但不规定具体的存储方式。</li>
<li>范围：Unicode字符集的范围是从U+0000到U+10FFFF，支持超过百万个字符。</li>
</ul>
<h4 id="UTF-x："><a href="#UTF-x：" class="headerlink" title="UTF-x："></a>UTF-x：</h4><ul>
<li>定义：UTF-x（Unicode Transformation Format）是Unicode的具体编码实现，用于将Unicode字符转换为二进制数据以便存储或传输。</li>
<li>关系：UTF-x是Unicode的实现方式，负责将Unicode字符集映射到实际的字节序列。</li>
<li>常见类型：<ul>
<li>UTF-8：一种变长编码，每个字符使用1到4个字节。</li>
<li>UTF-16：一种变长编码，每个字符使用2或4个字节。</li>
<li>UTF-32：一种固定长度编码，每个字符使用4个字节。</li>
</ul>
</li>
</ul>
<h3 id="软件本地化基本步骤"><a href="#软件本地化基本步骤" class="headerlink" title="软件本地化基本步骤"></a>软件本地化基本步骤</h3><ul>
<li>建立配置管理体系，跟踪目标语言各个版本的源代码</li>
<li>创造和维护术语表</li>
<li>源语言代码和资源文件分离、或提取需要本地化的文本</li>
<li>把分离或提取的文本、图片等翻译成目标语言</li>
<li>把翻译好的文本、图片重新检入目标语言的源代码版本</li>
<li>如果需要，编译目标语言的源代码</li>
<li>测试翻译后的软件，调整UI 以适应翻译后的文本</li>
<li>测试本地化后的软件，确保格式和内容都正确<br><img src="/%E8%BD%AF%E4%BB%B6%E6%9C%AC%E5%9C%B0%E5%8C%96%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4.png" alt="软件本地化基本步骤"></li>
</ul>
<h3 id="本地化测试主要有哪些工作"><a href="#本地化测试主要有哪些工作" class="headerlink" title="本地化测试主要有哪些工作"></a>本地化测试主要有哪些工作</h3><ul>
<li>功能性测试，所有基本功能、安装、升级等测试；</li>
<li>翻译测试，包括语言完整性、术语准确性等的检查；</li>
<li>可用性测试，包括用户界面、度量衡和时区等；</li>
<li>兼容性调试，包括硬件兼容性、版本兼容性等测试；</li>
<li>文化、宗教、喜好等适用性测试</li>
<li>手册验证，包括联机文件、在线帮助、PDF文件等测试</li>
</ul>
<h3 id="软件本地化测试完整路线"><a href="#软件本地化测试完整路线" class="headerlink" title="软件本地化测试完整路线"></a>软件本地化测试完整路线</h3><h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><h3 id="自动化测试与测试自动化"><a href="#自动化测试与测试自动化" class="headerlink" title="自动化测试与测试自动化"></a>自动化测试与测试自动化</h3><ul>
<li>通过平台、系统或工具自动地完成测试的某类工作都可以归为测试自动化</li>
<li>自动化测试更侧重的测试用例或测试数据生成、测试执行和测试结果呈现等自动化</li>
</ul>
<h3 id="如何理解测试自动化"><a href="#如何理解测试自动化" class="headerlink" title="如何理解测试自动化"></a>如何理解测试自动化</h3><h3 id="测试自动化实现的原理，几种技术"><a href="#测试自动化实现的原理，几种技术" class="headerlink" title="测试自动化实现的原理，几种技术"></a>测试自动化实现的原理，几种技术</h3><h3 id="自动化测试的流程"><a href="#自动化测试的流程" class="headerlink" title="自动化测试的流程"></a>自动化测试的流程</h3><h3 id="几种脚本技术"><a href="#几种脚本技术" class="headerlink" title="几种脚本技术"></a>几种脚本技术</h3><h3 id="自动化功能测试基本构成"><a href="#自动化功能测试基本构成" class="headerlink" title="自动化功能测试基本构成"></a>自动化功能测试基本构成</h3><h3 id="TA框架的构成及各部分特点"><a href="#TA框架的构成及各部分特点" class="headerlink" title="TA框架的构成及各部分特点"></a>TA框架的构成及各部分特点</h3><p><img src="/TA%E6%A1%86%E6%9E%B6%E7%9A%84%E6%9E%84%E6%88%90.png" alt="TA框架的构成"></p>
